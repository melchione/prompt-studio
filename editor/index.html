<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prompt Editor - Cowai</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --bg-editor: #1e1e1e;
      --text-primary: #f8fafc;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --border-color: #475569;
      --accent-blue: #3b82f6;
      --accent-green: #22c55e;
      --accent-yellow: #fcd34d;
      --accent-red: #dc2626;
      --accent-purple: #8b5cf6;
      --sidebar-width: 260px;
      --header-height: 56px;
      --diff-panel-height: 200px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow: hidden;
      height: 100vh;
    }

    #app {
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: 1fr;
      height: 100vh;
    }

    /* HEADER */
    header {
      grid-area: header;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 12px;
    }

    .logo {
      font-weight: 700;
      font-size: 1.1rem;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo-icon {
      font-size: 1.4rem;
    }

    .agent-selector,
    .lang-toggle {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 12px;
      color: var(--text-primary);
      font-size: 0.875rem;
      cursor: pointer;
    }

    .agent-selector:focus,
    .lang-toggle:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .agent-selector {
      min-width: 220px;
    }

    .agent-selector option {
      background: var(--bg-secondary);
      padding: 4px 8px;
    }

    .agent-selector optgroup {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-weight: 600;
      font-size: 0.85rem;
      padding: 8px 4px 4px 4px;
    }

    .agent-selector optgroup option {
      font-weight: 400;
      color: var(--text-primary);
      padding-left: 12px;
    }

    .current-file {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 0.8rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .current-file .file-icon {
      opacity: 0.7;
    }

    .lang-toggle {
      display: flex;
      gap: 0;
      padding: 0;
      overflow: hidden;
    }

    .lang-toggle button {
      background: transparent;
      border: none;
      padding: 8px 14px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    .lang-toggle button.active {
      background: var(--accent-blue);
      color: white;
    }

    .lang-toggle button:hover:not(.active) {
      background: var(--bg-secondary);
    }

    .header-spacer {
      flex: 1;
    }

    .header-actions {
      display: flex;
      gap: 8px;
    }

    .btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 14px;
      color: var(--text-primary);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .btn:hover {
      background: var(--border-color);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
    }

    .btn-primary:hover {
      background: #2563eb;
    }

    .btn-success {
      background: var(--accent-green);
      border-color: var(--accent-green);
      color: #000;
    }

    .btn-success:hover {
      background: #16a34a;
    }

    .btn-warning {
      background: var(--accent-yellow);
      border-color: var(--accent-yellow);
      color: #000;
    }

    .btn-warning:hover {
      background: #eab308;
    }

    .btn-expand {
      background: var(--accent-purple);
      border-color: var(--accent-purple);
    }

    .btn-expand:hover {
      background: #7c3aed;
    }

    .modified-indicator {
      display: none;
      width: 8px;
      height: 8px;
      background: var(--accent-yellow);
      border-radius: 50%;
    }

    .modified-indicator.show {
      display: block;
    }

    /* SIDEBAR */
    #sidebar {
      grid-area: sidebar;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .sidebar-section {
      padding: 12px;
    }

    .sidebar-section+.sidebar-section {
      border-top: 1px solid var(--border-color);
    }

    .section-title {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .sections-list {
      list-style: none;
    }

    .section-item {
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.15s;
    }

    .section-item:hover {
      background: var(--bg-tertiary);
    }

    .section-item.active {
      background: var(--accent-blue);
      color: white;
    }

    .section-item .section-num {
      font-size: 0.7rem;
      opacity: 0.7;
      min-width: 20px;
    }

    .section-item .section-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .section-item .lang-badge {
      font-size: 0.65rem;
      padding: 2px 5px;
      border-radius: 3px;
      background: var(--bg-tertiary);
    }

    .section-item.active .lang-badge {
      background: rgba(255, 255, 255, 0.2);
    }

    .section-item .lang-badge.missing {
      color: var(--accent-red);
    }

    /* Actions */
    .sidebar-actions {
      margin-top: auto;
      padding: 12px;
      border-top: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sidebar-actions .btn {
      width: 100%;
      justify-content: center;
    }

    /* FLOATING SECTIONS NAV */
    .floating-sections-nav {
      position: fixed;
      left: 16px;
      top: calc(var(--header-height) + 16px);
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .floating-section-item {
      display: flex;
      align-items: center;
      width: 36px;
      height: 36px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      cursor: pointer;
      transition: width 0.2s ease, background 0.15s;
      overflow: hidden;
      white-space: nowrap;
    }

    .floating-section-item:hover {
      width: 200px;
      background: var(--bg-tertiary);
    }

    .floating-section-item.active {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }

    .floating-section-num {
      min-width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 600;
      flex-shrink: 0;
    }

    .floating-section-name {
      padding-right: 12px;
      font-size: 0.8rem;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .floating-section-item:hover .floating-section-name {
      opacity: 1;
    }

    .floating-reorder-btn,
    .floating-add-btn {
      width: 36px;
      height: 36px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      color: var(--text-secondary);
      transition: all 0.15s;
    }

    .floating-reorder-btn:hover {
      background: var(--accent-purple);
      border-color: var(--accent-purple);
      color: white;
    }

    .floating-reorder-btn.active {
      background: var(--accent-purple);
      border-color: var(--accent-purple);
      color: white;
    }

    .floating-add-btn {
      border-style: dashed;
    }

    .floating-add-btn:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
      background: rgba(59, 130, 246, 0.1);
    }

    /* Reorder mode */
    .floating-sections-nav.reorder-mode .floating-section-item {
      width: 200px;
      cursor: grab;
    }

    .floating-sections-nav.reorder-mode .floating-section-name {
      opacity: 1;
    }

    .floating-section-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
      background: var(--accent-purple);
    }

    .floating-section-item.drag-over {
      border-color: var(--accent-yellow);
      border-width: 2px;
    }

    /* SPLIT MODE (Default Layout) */
    .split-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      width: 100%;
      height: 100%;
    }

    .split-panel {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .split-panel:first-child {
      border-right: 2px solid var(--border-color);
    }

    .split-panel-header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      padding: 8px 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .split-panel-header .agent-selector {
      min-width: 140px;
      font-size: 0.8rem;
      padding: 6px 10px;
    }

    .split-panel-header .lang-toggle {
      font-size: 0.75rem;
    }

    .split-panel-header .lang-toggle button {
      padding: 6px 10px;
    }

    .split-panel-content {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .split-monaco-container {
      width: 100%;
      height: 100%;
    }

    /* Floating nav for split panels */
    .split-floating-nav {
      position: absolute;
      left: 12px;
      top: 12px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .split-add-section-btn {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      border: 1px dashed var(--border-color);
      background: transparent;
      color: var(--text-muted);
      font-size: 18px;
      font-weight: 300;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 4px;
      transition: all 0.15s ease;
    }

    .split-add-section-btn:hover {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }

    .btn-split {
      background: var(--accent-purple);
      border-color: var(--accent-purple);
    }

    .btn-split:hover {
      background: #7c3aed;
    }

    .btn-split.active {
      background: var(--accent-green);
      border-color: var(--accent-green);
    }

    /* Split Panel Modes (Preview/Diff) */
    .split-panel-btn {
      padding: 4px 8px;
      font-size: 0.75rem;
    }

    .split-panel-btn.active {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
    }

    .split-preview-content,
    .split-diff-container {
      display: none;
      width: 100%;
      height: 100%;
    }

    .split-panel.preview-mode .split-monaco-container {
      display: none;
    }

    .split-panel.preview-mode .split-preview-content {
      display: block;
      overflow-y: auto;
      padding: 16px 24px;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .split-panel.diff-mode .split-monaco-container {
      display: none;
    }

    .split-panel.diff-mode .split-diff-container {
      display: block;
    }

    /* MAIN */
    #main {
      grid-area: main;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .editor-container {
      flex: 1;
      display: flex;
      overflow: hidden;
      position: relative;
    }

    .editor-pane {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
    }

    .pane-header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      padding: 8px 12px;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .preview-header-actions {
      display: flex;
      gap: 6px;
    }

    .preview-header-btn {
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preview-header-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-blue);
    }

    .preview-header-btn.copied {
      background: var(--accent-green);
      border-color: var(--accent-green);
    }

    #monaco-container {
      flex: 1;
      min-height: 0;
    }

    .resizer {
      width: 4px;
      background: var(--border-color);
      cursor: col-resize;
      transition: background 0.2s;
    }

    .resizer:hover {
      background: var(--accent-blue);
    }

    .preview-pane {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
    }

    /* ===========================================
       PREVIEW PANEL - Visual Hierarchy System
       Based on typographic scale 1.25 (Major Third)
       =========================================== */

    /* Base Container - Dark Mode (default) */
    #preview-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px 24px;
      background: #0a0a0a;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 14px;
      line-height: 1.65;
      color: #a3a3a3;
      /* Muted for body text */
    }

    /* Light Mode */
    .preview-pane.light-mode #preview-content {
      background: #faf8f5;
      color: #57534e;
      /* Muted brown for body */
    }

    /* --- LEVEL 1: Primary Heading (H1) ---
       Largest, most prominent, section divider */
    #preview-content h1 {
      font-size: 1.5rem;
      /* 24px - largest */
      font-weight: 700;
      /* Bold */
      line-height: 1.3;
      margin: 32px 0 12px 0;
      /* Large top margin = new section */
      padding-bottom: 8px;
      border-bottom: 1px solid #2a2a2a;
      color: #f5f5f5;
      /* High contrast */
      letter-spacing: -0.01em;
    }

    #preview-content h1:first-child {
      margin-top: 0;
      /* No top margin for first H1 */
    }

    .preview-pane.light-mode #preview-content h1 {
      border-bottom-color: #d6d3d1;
      color: #1c1917;
    }

    /* --- LEVEL 2: Secondary Heading (H2) ---
       Sub-sections, prominent but subordinate */
    #preview-content h2 {
      font-size: 1.2rem;
      /* 19px */
      font-weight: 600;
      /* Semibold */
      line-height: 1.35;
      margin: 28px 0 8px 0;
      /* Good separation */
      color: #fbbf24;
      /* Amber accent - draws attention */
      letter-spacing: -0.005em;
    }

    .preview-pane.light-mode #preview-content h2 {
      color: #b45309;
      /* Dark amber */
    }

    /* --- LEVEL 3: Tertiary Heading (H3) ---
       Minor sections, less prominent */
    #preview-content h3 {
      font-size: 1rem;
      /* 16px */
      font-weight: 600;
      line-height: 1.4;
      margin: 20px 0 6px 0;
      color: #d4a855;
      /* Softer amber */
    }

    .preview-pane.light-mode #preview-content h3 {
      color: #a16207;
    }

    /* --- LEVEL 4: Quaternary Heading (H4) ---
       Minimal emphasis */
    #preview-content h4 {
      font-size: 0.9rem;
      /* 14px */
      font-weight: 600;
      line-height: 1.4;
      margin: 16px 0 4px 0;
      color: #c9b896;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .preview-pane.light-mode #preview-content h4 {
      color: #78716c;
    }

    /* --- BODY TEXT: Paragraphs ---
       Readable, slightly muted */
    #preview-content p {
      margin: 0 0 12px 0;
      line-height: 1.65;
    }

    /* --- LISTS ---
       Aligned with body text, compact spacing */
    #preview-content ul,
    #preview-content ol {
      margin: 0 0 12px 0;
      padding-left: 20px;
    }

    #preview-content li {
      margin-bottom: 4px;
      line-height: 1.55;
    }

    #preview-content li::marker {
      color: #525252;
    }

    .preview-pane.light-mode #preview-content li::marker {
      color: #a8a29e;
    }

    /* --- EMPHASIS: Strong/Bold ---
       Slightly brighter than body */
    #preview-content strong {
      font-weight: 600;
      color: #e5e5e5;
    }

    .preview-pane.light-mode #preview-content strong {
      color: #292524;
    }

    /* --- EMPHASIS: Italic --- */
    #preview-content em {
      font-style: italic;
      color: #b5b5b5;
    }

    .preview-pane.light-mode #preview-content em {
      color: #44403c;
    }

    /* Hide horizontal rules */
    #preview-content hr {
      display: none;
    }

    /* Hide br tags after headings */
    #preview-content h1+br,
    #preview-content h2+br,
    #preview-content h3+br,
    #preview-content h4+br {
      display: none;
    }

    /* --- CODE: Inline ---
       Distinct background, accent color */
    #preview-content code {
      background: #1a1a1a;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', 'Monaco', 'Menlo', monospace;
      font-size: 0.85em;
      color: #f59e0b;
    }

    .preview-pane.light-mode #preview-content code {
      background: #f5f0e8;
      color: #c2410c;
    }

    /* --- CODE: Block ---
       Prominent container */
    #preview-content pre {
      background: #111111;
      padding: 14px 16px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 16px 0;
      border: 1px solid #1f1f1f;
    }

    #preview-content pre code {
      background: transparent;
      padding: 0;
      color: #d4d4d4;
    }

    .preview-pane.light-mode #preview-content pre {
      background: #f5f0e8;
      border-color: #e7e5e4;
    }

    .preview-pane.light-mode #preview-content pre code {
      color: #44403c;
    }

    /* --- BLOCKQUOTE ---
       Distinct, indented, subdued */
    #preview-content blockquote {
      border-left: 3px solid #404040;
      padding-left: 16px;
      margin: 16px 0;
      color: #737373;
      font-style: italic;
    }

    .preview-pane.light-mode #preview-content blockquote {
      border-left-color: #d6d3d1;
      color: #78716c;
    }

    #preview-content .protected-token {
      background: #6b5b3e;
      color: #fef3c7;
      padding: 1px 4px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 0.85em;
    }

    /* Section delimiters in preview - subtle styling */
    #preview-content .section-delimiter {
      display: none;
    }

    /* DIFF PANEL */
    #diff-panel {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: none;
      flex-direction: column;
      background: var(--bg-secondary);
      z-index: 50;
    }

    #diff-panel.open {
      display: flex;
    }

    .diff-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }

    .diff-title {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .diff-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.2rem;
    }

    .diff-close:hover {
      color: var(--text-primary);
    }

    #diff-container {
      flex: 1;
      min-height: 0;
    }

    /* MODAL */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-title {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.4rem;
      cursor: pointer;
    }

    .modal-close:hover {
      color: var(--text-primary);
    }

    .modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .modal-footer {
      padding: 16px 20px;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    /* TOAST */
    #toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1001;
    }

    .toast {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      animation: slideIn 0.3s ease;
      min-width: 280px;
    }

    .toast.success {
      border-color: var(--accent-green);
    }

    .toast.error {
      border-color: var(--accent-red);
    }

    .toast.warning {
      border-color: var(--accent-yellow);
    }

    .toast-icon {
      font-size: 1.2rem;
    }

    .toast.success .toast-icon {
      color: var(--accent-green);
    }

    .toast.error .toast-icon {
      color: var(--accent-red);
    }

    .toast.warning .toast-icon {
      color: var(--accent-yellow);
    }

    .toast-message {
      flex: 1;
      font-size: 0.9rem;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* LOADING */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .loading-overlay.show {
      display: flex;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid var(--border-color);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .loading-text {
      color: var(--text-primary);
      margin-top: 16px;
      font-size: 0.9rem;
    }

    /* Section Actions */
    .section-item .section-actions {
      display: none;
      gap: 2px;
      margin-left: auto;
    }

    .section-item:hover .section-actions {
      display: flex;
    }

    .section-item.active .section-actions {
      display: flex;
    }

    .section-action-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 0.8rem;
      line-height: 1;
      transition: all 0.15s;
    }

    .section-action-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .section-item.active .section-action-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .section-action-btn.danger:hover {
      background: var(--accent-red);
      color: white;
    }

    /* Add Section Button */
    .add-section-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      width: 100%;
      padding: 10px;
      margin-top: 8px;
      background: var(--bg-tertiary);
      border: 1px dashed var(--border-color);
      border-radius: 6px;
      color: var(--text-muted);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .add-section-btn:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
      background: rgba(59, 130, 246, 0.1);
    }

    /* Modal Input */
    .modal-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 10px 12px;
      color: var(--text-primary);
      font-size: 0.9rem;
      margin-bottom: 12px;
    }

    .modal-input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .modal-label {
      display: block;
      margin-bottom: 6px;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .modal-hint {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: -8px;
      margin-bottom: 12px;
    }

    .modal-select {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 10px 12px;
      color: var(--text-primary);
      font-size: 0.9rem;
      cursor: pointer;
    }

    .modal-select:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .modal-select:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .include-preview {
      display: block;
      background: var(--bg-tertiary);
      padding: 12px 16px;
      border-radius: 6px;
      font-family: 'SF Mono', Monaco, Consolas, monospace;
      font-size: 0.9rem;
      color: var(--accent-green);
      border: 1px solid var(--border-color);
    }

    /* Monaco Editor Section Decorations */
    .section-delimiter-line {
      background: linear-gradient(90deg, var(--accent-purple) 0%, transparent 100%) !important;
      opacity: 0.15;
    }

    .section-glyph-marker {
      background: var(--accent-purple);
      width: 4px !important;
      margin-left: 3px;
    }

    .section-highlight-flash {
      background: var(--accent-yellow) !important;
      opacity: 0.3;
      animation: flashHighlight 1.5s ease-out;
    }

    @keyframes flashHighlight {
      0% {
        opacity: 0.5;
      }

      100% {
        opacity: 0;
      }
    }

    /* Monaco Editor Include Decorations */
    .include-start-line,
    .include-end-line {
      background: linear-gradient(90deg, var(--accent-green) 0%, transparent 100%) !important;
      opacity: 0.2;
    }

    .include-glyph-start,
    .include-glyph-end {
      background: var(--accent-green);
      width: 4px !important;
      margin-left: 3px;
    }

    /* Collapse Buttons */
    .collapse-btn {
      position: absolute;
      z-index: 20;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 6px 8px;
      cursor: pointer;
      transition: all 0.2s;
      color: var(--text-secondary);
      font-size: 0.75rem;
      line-height: 1;
    }

    .collapse-btn:hover {
      background: var(--border-color);
      color: var(--text-primary);
    }

    .collapse-sidebar-btn {
      top: 50%;
      left: var(--sidebar-width);
      transform: translate(-50%, -50%);
      z-index: 100;
    }

    .collapse-preview-btn {
      top: 50%;
      right: 0;
      transform: translate(-50%, -50%);
    }

    /* Sidebar collapse transition */
    #sidebar {
      transition: width 0.3s ease, min-width 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
      min-width: var(--sidebar-width);
    }

    #sidebar.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
    }

    /* Preview collapse transition */
    .preview-pane {
      transition: flex 0.3s ease, width 0.3s ease, min-width 0.3s ease, padding 0.3s ease;
      min-width: 200px;
      position: relative;
    }

    .preview-pane.collapsed {
      flex: 0 0 0 !important;
      min-width: 0 !important;
      width: 0 !important;
      overflow: hidden;
    }

    .preview-pane.collapsed .pane-header,
    .preview-pane.collapsed #preview-content {
      display: none;
    }

    /* Keep collapse button visible when preview is collapsed */
    .preview-pane.collapsed .collapse-preview-btn {
      display: flex;
      position: fixed;
      right: 8px;
      top: calc(var(--header-height) + 50%);
      transform: translateY(-50%);
      z-index: 150;
    }

    /* Resizer hidden when preview collapsed */
    .resizer.hidden {
      display: none;
    }

    /* Grid adjustment when sidebar collapsed */
    #app.sidebar-collapsed {
      grid-template-columns: 0 1fr;
    }

    #app.sidebar-collapsed .collapse-sidebar-btn {
      left: 0;
      transform: translate(0, -50%);
      border-left: none;
      border-radius: 0 4px 4px 0;
    }
  </style>
</head>

<body>
  <div id="app">
    <!-- Split Mode Container (Main Editor) -->
    <div class="split-container" id="split-container">
      <!-- Left Panel -->
      <div class="split-panel" id="split-panel-left">
        <div class="split-panel-header">
          <select class="agent-selector split-project-select" data-panel="left"></select>
          <select class="agent-selector split-agent-select" data-panel="left"></select>
          <div class="lang-toggle">
            <button class="split-lang-btn active" data-panel="left" data-lang="fr">FR</button>
            <button class="split-lang-btn" data-panel="left" data-lang="en">EN</button>
          </div>
          <div class="header-spacer"></div>
          <button class="btn split-panel-btn split-expand-btn" data-panel="left" title="Expand/Collapse includes" style="display: none;">
            <span>&#128194;</span> <span class="expand-label">Expand</span>
          </button>
          <button class="btn split-panel-btn split-preview-btn" data-panel="left" title="Afficher preview">
            <span>&#128065;</span> Preview
          </button>
          <button class="btn split-panel-btn split-diff-btn" data-panel="left" title="Afficher diff">
            <span>&#128203;</span> Diff
          </button>
        </div>
        <div class="split-panel-content">
          <nav class="split-floating-nav" data-panel="left">
            <div class="split-sections-list" data-panel="left"></div>
          </nav>
          <div class="split-monaco-container" id="split-monaco-left"></div>
          <div class="split-preview-content" data-panel="left"></div>
          <div class="split-diff-container" id="split-diff-left" data-panel="left"></div>
        </div>
      </div>

      <!-- Right Panel -->
      <div class="split-panel" id="split-panel-right">
        <div class="split-panel-header">
          <select class="agent-selector split-project-select" data-panel="right"></select>
          <select class="agent-selector split-agent-select" data-panel="right"></select>
          <div class="lang-toggle">
            <button class="split-lang-btn active" data-panel="right" data-lang="fr">FR</button>
            <button class="split-lang-btn" data-panel="right" data-lang="en">EN</button>
          </div>
          <div class="header-spacer"></div>
          <button class="btn split-panel-btn split-expand-btn" data-panel="right" title="Expand/Collapse includes" style="display: none;">
            <span>&#128194;</span> <span class="expand-label">Expand</span>
          </button>
          <button class="btn split-panel-btn split-preview-btn" data-panel="right" title="Afficher preview">
            <span>&#128065;</span> Preview
          </button>
          <button class="btn split-panel-btn split-diff-btn" data-panel="right" title="Afficher diff">
            <span>&#128203;</span> Diff
          </button>
        </div>
        <div class="split-panel-content">
          <nav class="split-floating-nav" data-panel="right">
            <div class="split-sections-list" data-panel="right"></div>
          </nav>
          <div class="split-monaco-container" id="split-monaco-right"></div>
          <div class="split-preview-content" data-panel="right"></div>
          <div class="split-diff-container" id="split-diff-right" data-panel="right"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal Cr√©ation Section -->
  <div class="modal-overlay" id="create-section-modal">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <span class="modal-title">&#10133; Nouvelle Section</span>
        <button class="modal-close" onclick="closeCreateSectionModal()">&times;</button>
      </div>
      <div class="modal-body">
        <label class="modal-label">Nom de la section</label>
        <input type="text" id="new-section-name" class="modal-input" placeholder="ex: instructions" autocomplete="off">
        <p class="modal-hint">Le num√©ro sera attribu√© automatiquement (ex: 12-instructions.md)</p>
      </div>
      <div class="modal-footer">
        <button class="btn" onclick="closeCreateSectionModal()">Annuler</button>
        <button class="btn btn-primary" id="btn-confirm-create" onclick="confirmCreateSection()">
          Cr√©er
        </button>
      </div>
    </div>
  </div>

  <!-- Modal Confirmation Suppression -->
  <div class="modal-overlay" id="delete-confirm-modal">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <span class="modal-title">&#128465; Supprimer la section</span>
        <button class="modal-close" onclick="closeDeleteModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p>Voulez-vous vraiment supprimer <strong id="delete-section-name"></strong> ?</p>
        <p style="color: var(--accent-red); margin-top: 12px; font-size: 0.85rem;">
          &#9888; Cette action est irr√©versible.
        </p>
      </div>
      <div class="modal-footer">
        <button class="btn" onclick="closeDeleteModal()">Annuler</button>
        <button class="btn" style="background: var(--accent-red); border-color: var(--accent-red);"
          onclick="confirmDeleteSection()">
          Supprimer
        </button>
      </div>
    </div>
  </div>

  <!-- Insert Include Modal -->
  <div id="insert-include-modal" class="modal-overlay">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <span class="modal-title">&#128194; Ins√©rer un Include</span>
        <button class="modal-close" onclick="closeInsertIncludeModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label class="modal-label">Projet source</label>
          <select id="include-project-select" class="modal-select" onchange="onIncludeProjectChange()">
            <option value="">-- S√©lectionner un projet --</option>
          </select>
        </div>
        <div class="form-group">
          <label class="modal-label">Agent source</label>
          <select id="include-agent-select" class="modal-select" onchange="onIncludeAgentChange()" disabled>
            <option value="">-- S√©lectionner un agent --</option>
          </select>
        </div>
        <div class="form-group">
          <label class="modal-label">Section</label>
          <select id="include-section-select" class="modal-select" disabled>
            <option value="">-- S√©lectionner une section --</option>
          </select>
        </div>
        <div class="form-group">
          <label class="modal-label">Aper√ßu</label>
          <code id="include-preview" class="include-preview">{% include '' %}</code>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn" onclick="closeInsertIncludeModal()">Annuler</button>
        <button class="btn btn-primary" id="btn-insert-include" onclick="insertIncludeAtCursor()" disabled>
          Ins√©rer
        </button>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div id="toast-container"></div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading">
    <div style="text-align: center;">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loading-text">Chargement...</div>
    </div>
  </div>

  <!-- Monaco Editor CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
  <!-- markdown-it for Markdown (cleaner than marked) -->
  <script type="module">
    import markdownIt from 'https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/+esm';

    // Initialize and expose globally
    window.md = markdownIt({
      html: true,
      linkify: true,
      typographer: false,
      breaks: false  // Don't convert \n to <br>
    });

    console.log('markdown-it initialized successfully');

    // Dispatch event to notify that md is ready
    window.dispatchEvent(new Event('markdown-ready'));
  </script>

  <script>
    // ============================================
    // MARKDOWN HELPER (waits for ESM module)
    // ============================================
    function renderMarkdown(text) {
      if (window.md && window.md.render) {
        return window.md.render(text);
      }
      // Fallback if markdown-it not yet loaded
      return text
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>')
        .replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/gim, '<em>$1</em>')
        .replace(/```([\s\S]*?)```/gim, '<pre><code>$1</code></pre>')
        .replace(/`([^`]+)`/gim, '<code>$1</code>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/^/, '<p>')
        .replace(/$/, '</p>');
    }

    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      apiBase: '/api',  // Relatif - fonctionne sur n'importe quel port
      promptsPath: 'projects',
      distPath: 'projects',
    };

    // ============================================
    // STATE
    // ============================================
    const state = {
      projects: [],
      currentProject: null,
      agents: {},
      protectedTokens: [],
      currentAgent: null,
      currentSection: null,  // Currently highlighted section in sidebar
      currentLang: 'fr',
      originalContent: '',   // Original concatenated content
      originalSections: {},  // Original content per section { sectionName: content }
      sectionBoundaries: [], // Array of { section, startLine, endLine }
      isModified: false,
      editor: null,
      diffEditor: null,
      isExpanded: true,      // Track if includes are expanded
      hasIncludes: false,    // Track if content has includes
      insertIncludePosition: null,  // Store cursor position for include insertion
      insertIncludePanelId: null,   // Store which panel is inserting (split mode)
      availableIncludes: {},        // Cache of available includes by agent
      includeCompletions: [],       // Cache for autocompletion suggestions
      isReorderMode: false,         // Track if reorder mode is active
      splitMode: false,             // Track if split mode is active
      splitCreatePanelId: null,     // Track which panel is creating a section
      panels: {
        left: {
          project: null,
          agent: null,
          lang: 'fr',
          sections: [],
          editor: null,
          originalContent: '',
          originalSections: {},
          sectionBoundaries: [],
          isModified: false,
          hasIncludes: false,
          isExpanded: false
        },
        right: {
          project: null,
          agent: null,
          lang: 'fr',
          sections: [],
          editor: null,
          originalContent: '',
          originalSections: {},
          sectionBoundaries: [],
          isModified: false,
          hasIncludes: false,
          isExpanded: false
        }
      }
    };

    // Section delimiter pattern
    const SECTION_DELIMITER_START = '<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->';
    const SECTION_DELIMITER_PATTERN = /<!-- üìÑ SECTION: (.+\.md) -->/;

    // ============================================
    // API CALLS (Multi-projet)
    // ============================================
    const api = {
      // Projets
      async getProjects() {
        const res = await fetch(`${CONFIG.apiBase}/projects`);
        if (!res.ok) throw new Error('Failed to load projects');
        return res.json();
      },

      // Agents (requires project)
      async getAgents(project) {
        if (!project) throw new Error('No project selected');
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents`);
        if (!res.ok) throw new Error('Failed to load agents');
        return res.json();
      },

      // Sections
      async getSection(project, agent, lang, section) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/${lang}/${section}`);
        if (!res.ok) throw new Error('Failed to load section');
        return res.json();
      },

      async saveSection(project, agent, lang, section, content) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/${lang}/${section}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content }),
        });
        if (!res.ok) throw new Error('Failed to save section');
        return res.json();
      },

      async deleteSection(project, agent, lang, section) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/delete-section`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lang, section }),
        });
        if (!res.ok) throw new Error('Failed to delete section');
        return res.json();
      },

      async createSection(project, agent, lang, name) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/${lang}/${name}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: `# ${name}\n\nContenu de la section...` }),
        });
        if (!res.ok) throw new Error('Failed to create section');
        return res.json();
      },

      // Op√©rations
      async buildPrompt(project, agent, lang) {
        const res = await fetch(`${CONFIG.apiBase}/build`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ project, agent, lang }),
        });
        if (!res.ok) throw new Error('Failed to build prompt');
        return res.json();
      },

      async translate(project, agent, data) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/translate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        if (!res.ok) throw new Error('Failed to translate');
        return res.json();
      },

      async getProtectedTokens() {
        const res = await fetch(`${CONFIG.apiBase}/protected-tokens`);
        if (!res.ok) return { tokens: ['{% include', '{%', '%}', '{{', '}}', '$state', '$derived', '$effect'] };
        return res.json();
      },

      async reorderSections(project, agent, lang, sections) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/reorder`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lang, order: sections }),
        });
        if (!res.ok) throw new Error('Failed to reorder sections');
        return res.json();
      },

      async getAllSections(project, agent, lang) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/${lang}/all`);
        if (!res.ok) throw new Error('Failed to load all sections');
        return res.json();
      },

      // Get list of section names only
      async getSections(project, agent, lang) {
        const data = await this.getAllSections(project, agent, lang);
        // data.order is an array of section names, data.sections is an object
        return data.order || Object.keys(data.sections || {});
      },

      // Get content of a single section
      async getSectionContent(project, agent, lang, section) {
        const data = await this.getSection(project, agent, lang, section);
        return data.content || '';
      },

      async saveAllSections(project, agent, lang, sections) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/${lang}/save-all`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(sections),
        });
        if (!res.ok) throw new Error('Failed to save sections');
        return res.json();
      },

      async expandIncludes(project, agent, lang, section) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/expand?lang=${lang}&section=${section}`);
        if (!res.ok) throw new Error('Failed to expand includes');
        return res.json();
      },

      async collapseIncludes(project, agent, data) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/collapse`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        if (!res.ok) throw new Error('Failed to collapse includes');
        return res.json();
      },

      async saveWithIncludes(project, agent, lang, section, content) {
        const res = await fetch(`${CONFIG.apiBase}/projects/${project}/agents/${agent}/${lang}/${section}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content, collapse: true }),
        });
        if (!res.ok) throw new Error('Failed to save with includes');
        return res.json();
      },
    };

    // ============================================
    // HELPER FUNCTIONS FOR API CALLS
    // ============================================
    async function expandContentWithIncludes(content, lang) {
      console.log('[expandContentWithIncludes] project:', state.currentProject, 'lang:', lang);
      console.log('[expandContentWithIncludes] content has includes:', content.includes('{% include'));
      const res = await fetch(`${CONFIG.apiBase}/expand`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content, lang, project: state.currentProject }),
      });
      if (!res.ok) {
        const errorText = await res.text();
        console.error('[expandContentWithIncludes] API error:', res.status, errorText);
        return { expanded: content, has_includes: false };
      }
      const result = await res.json();
      console.log('[expandContentWithIncludes] result has_includes:', result.has_includes);
      return result;
    }

    async function collapseContentWithIncludes(content, lang) {
      const res = await fetch(`${CONFIG.apiBase}/collapse-content`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content, lang }),
      });
      if (!res.ok) throw new Error('Failed to collapse includes');
      return res.json();
    }

    // ============================================
    // UI HELPERS
    // ============================================
    function showLoading(show, text = 'Chargement...') {
      const el = document.getElementById('loading');
      document.getElementById('loading-text').textContent = text;
      el.classList.toggle('show', show);
    }

    function showToast(message, type = 'info') {
      const container = document.getElementById('toast-container');
      const icons = {
        success: '&#10004;',
        error: '&#10006;',
        warning: '&#9888;',
        info: '&#8505;',
      };
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <span class="toast-icon">${icons[type] || icons.info}</span>
        <span class="toast-message">${message}</span>
      `;
      container.appendChild(toast);
      setTimeout(() => toast.remove(), 4000);
    }

    function setModified(modified) {
      state.isModified = modified;
      // Elements may not exist in split-only mode
      const indicator = document.getElementById('modified-indicator');
      const btn = document.getElementById('btn-save');
      if (indicator) indicator.classList.toggle('show', modified);
      if (btn) btn.disabled = !modified;
    }

    // ============================================
    // EDITOR FUNCTIONS
    // ============================================
    function initMonaco(callback) {
      require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' } });
      require(['vs/editor/editor.main'], function () {
        // Define custom theme
        monaco.editor.defineTheme('cowai-dark', {
          base: 'vs-dark',
          inherit: true,
          rules: [],
          colors: {
            'editor.background': '#1e1e1e',
          }
        });

        // Register completion provider for includes
        monaco.languages.registerCompletionItemProvider('markdown', {
          triggerCharacters: ["'", '"'],
          provideCompletionItems: async function (model, position) {
            // Get text before cursor on current line
            const textUntilPosition = model.getValueInRange({
              startLineNumber: position.lineNumber,
              startColumn: 1,
              endLineNumber: position.lineNumber,
              endColumn: position.column
            });

            // Check if we're inside an include directive
            const includeMatch = textUntilPosition.match(/\{%\s*include\s+['"]([^'"]*)$/);
            if (!includeMatch) {
              return { suggestions: [] };
            }

            const partialInput = includeMatch[1] || '';

            // Load available includes if not cached
            if (!state.includeCompletions || state.includeCompletions.length === 0) {
              await loadIncludeCompletions();
            }

            // Filter and map suggestions
            const range = {
              startLineNumber: position.lineNumber,
              endLineNumber: position.lineNumber,
              startColumn: position.column - partialInput.length,
              endColumn: position.column
            };

            const suggestions = state.includeCompletions
              .filter(item => item.ref.toLowerCase().includes(partialInput.toLowerCase()))
              .map(item => ({
                label: item.ref,
                kind: monaco.languages.CompletionItemKind.File,
                detail: item.isCurrentProject
                  ? `${item.agent} / ${item.section}`
                  : `[${item.project}] ${item.agent} / ${item.section}`,
                insertText: item.ref,
                range: range,
                // Current project items first
                sortText: item.isCurrentProject ? `0_${item.ref}` : `1_${item.ref}`
              }));

            return { suggestions };
          }
        });

        if (callback) callback();
      });
    }

    function updatePreviewFromEditor(content) {
      const previewEl = document.getElementById('preview-content');
      if (!previewEl) return; // Element may not exist in split-only mode

      // Strip section delimiters for clean preview
      const cleanContent = content
        .replace(/<!-- ‚ïê+[^>]*-->/g, '')  // Remove all ‚ïê‚ïê‚ïê comment lines
        .replace(/<!-- üìÑ SECTION:[^>]*-->/g, '')  // Remove section markers
        .replace(/^---\s*$/gm, '')  // Remove standalone --- lines
        .replace(/^\s*[\r\n]/gm, '\n')  // Clean empty lines
        .replace(/\n{3,}/g, '\n\n')  // Normalize multiple newlines
        .trim();

      let html = renderMarkdown(cleanContent || '');
      let highlighted = html;
      state.protectedTokens.forEach(token => {
        const escaped = token.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`(${escaped})`, 'g');
        highlighted = highlighted.replace(regex, '<span class="protected-token">$1</span>');
      });
      previewEl.innerHTML = highlighted;
    }

    async function updatePreview(content) {
      const previewEl = document.getElementById('preview-content');
      if (!previewEl) return; // Element may not exist in split-only mode

      // Helper to clean content for preview
      function cleanForPreview(text) {
        return (text || '')
          .replace(/<!-- ‚ïê+[^>]*-->/g, '')  // Remove all ‚ïê‚ïê‚ïê comment lines
          .replace(/<!-- üìÑ SECTION:[^>]*-->/g, '')  // Remove section markers
          .replace(/^---\s*$/gm, '')  // Remove standalone --- lines
          .replace(/^\s*[\r\n]/gm, '\n')  // Clean empty lines
          .replace(/\n{3,}/g, '\n\n')  // Normalize multiple newlines
          .trim();
      }

      // Load full compiled prompt if available, otherwise show current section
      if (state.currentAgent && state.currentLang) {
        try {
          const res = await fetch(`${CONFIG.apiBase}/dist/${state.currentLang}/${state.currentAgent}`);
          if (res.ok) {
            const data = await res.json();
            const cleanContent = cleanForPreview(data.content);
            let html = renderMarkdown(cleanContent);

            // Highlight protected tokens in preview
            state.protectedTokens.forEach(token => {
              const escaped = token.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const regex = new RegExp(`(${escaped})`, 'g');
              html = html.replace(regex, '<span class="protected-token">$1</span>');
            });

            previewEl.innerHTML = html;

            // Auto-scroll to current section if loaded
            if (state.currentSection) {
              scrollToSectionInPreview();
            }
            return;
          }
        } catch (e) {
          console.warn('Could not load compiled prompt, showing section preview');
        }
      }

      // Fallback: show current section content
      const cleanContent = cleanForPreview(content);
      let html = renderMarkdown(cleanContent);
      let highlighted = html;
      state.protectedTokens.forEach(token => {
        const escaped = token.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`(${escaped})`, 'g');
        highlighted = highlighted.replace(regex, '<span class="protected-token">$1</span>');
      });
      previewEl.innerHTML = highlighted;
    }

    function scrollToSectionInPreview() {
      // Find the section heading in the preview based on section filename
      const sectionName = state.currentSection?.replace(/^\d+-/, '').replace('.md', '');
      if (!sectionName) return;

      const preview = document.getElementById('preview-content');
      if (!preview) return; // Element may not exist in split-only mode
      const headings = preview.querySelectorAll('h1, h2, h3');

      for (const h of headings) {
        const text = h.textContent.toLowerCase().replace(/[^a-z0-9√†√¢√§√©√®√™√´√Ø√Æ√¥√π√ª√º√ß]/g, '');
        const sectionLower = sectionName.toLowerCase().replace(/[^a-z0-9√†√¢√§√©√®√™√´√Ø√Æ√¥√π√ª√º√ß]/g, '');

        if (text.includes(sectionLower) || sectionLower.includes(text)) {
          // Highlight the section
          h.style.background = 'var(--accent-yellow)';
          h.style.color = 'var(--bg-primary)';
          h.style.padding = '4px 8px';
          h.style.borderRadius = '4px';

          // Scroll to it
          setTimeout(() => {
            h.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }, 100);

          // Remove highlight after 3 seconds
          setTimeout(() => {
            h.style.background = '';
            h.style.color = '';
            h.style.padding = '';
          }, 3000);

          break;
        }
      }
    }

    // ============================================
    // DIFF
    // ============================================
    function showDiff() {
      const panel = document.getElementById('diff-panel');
      if (panel.classList.contains('open')) {
        panel.classList.remove('open');
        return;
      }

      panel.classList.add('open');

      if (state.diffEditor) {
        state.diffEditor.dispose();
      }

      state.diffEditor = monaco.editor.createDiffEditor(document.getElementById('diff-container'), {
        automaticLayout: true,
        theme: 'cowai-dark',
        readOnly: true,
      });

      state.diffEditor.setModel({
        original: monaco.editor.createModel(state.originalContent, 'markdown'),
        modified: monaco.editor.createModel(state.editor.getValue(), 'markdown'),
      });
    }

    function closeDiff() {
      document.getElementById('diff-panel').classList.remove('open');
    }

    // ============================================
    // SECTIONS MANAGEMENT
    // ============================================
    // Agent categories configuration
    const AGENT_CATEGORIES = {
      main: {
        label: 'üìã Agents Principaux',
        agents: ['common', 'executive'],
        descriptions: {
          common: 'Partie commune √† tous les agents',
          executive: 'Executive Assistant (agent principal)'
        }
      },
      utility: {
        label: 'üîß Agents Utilitaires',
        agents: ['planner', 'executor', 'hitl', 'artifact', 'respondtouser', 'toolenrichment', 'projectinfo'],
        descriptions: {
          planner: 'Planificateur de t√¢ches',
          executor: 'Ex√©cuteur de plans',
          hitl: 'Human-in-the-Loop (interactions)',
          artifact: 'Gestion des artifacts',
          respondtouser: 'Formatage des r√©ponses',
          toolenrichment: 'Enrichissement des outils',
          projectinfo: 'Informations projet'
        }
      }
    };

    // ============================================
    // LOAD PROJECTS (Multi-projet)
    // ============================================
    async function loadProjects() {
      try {
        showLoading(true, 'Chargement des projets...');
        const data = await api.getProjects();
        state.projects = data.projects || [];

        // Populate split mode project selects
        populateSplitProjectSelects();

        // Restore both panels from localStorage
        await restorePanelStates();

        showLoading(false);
      } catch (error) {
        showLoading(false);
        showToast(`Erreur projets: ${error.message}`, 'error');
      }
    }

    async function restorePanelStates() {
      for (const panelId of ['left', 'right']) {
        const saved = getSavedPanelState(panelId);
        if (!saved) continue;

        const { project, agent, lang } = saved;

        // Check if project still exists
        if (!project || !state.projects.find(p => p.name === project)) continue;

        // Set project select
        const projectSelect = document.querySelector(`.split-project-select[data-panel="${panelId}"]`);
        if (projectSelect) {
          projectSelect.value = project;
        }

        // Load agents for this project
        try {
          const agentsData = await api.getAgents(project);
          const agents = agentsData.agents || [];

          // Populate agent select
          const agentSelect = document.querySelector(`.split-agent-select[data-panel="${panelId}"]`);
          if (agentSelect) {
            agentSelect.innerHTML = '<option value="">-- Agent --</option>';
            agents.forEach(a => {
              const option = document.createElement('option');
              option.value = a.name;
              option.textContent = a.name;
              agentSelect.appendChild(option);
            });

            // Select saved agent if exists
            if (agent && agents.find(a => a.name === agent)) {
              agentSelect.value = agent;

              // Update panel state
              const panel = state.panels[panelId];
              panel.project = project;
              panel.agent = agent;
              panel.lang = lang || 'fr';

              // Update lang buttons
              document.querySelectorAll(`.split-lang-btn[data-panel="${panelId}"]`).forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === panel.lang);
              });

              // Load sections
              const sections = await api.getSections(project, agent, panel.lang);
              panel.sections = sections;
              await loadSplitPanelContent(panelId);
            }
          }
        } catch (err) {
          console.error(`Failed to restore panel ${panelId}:`, err);
        }
      }
    }

    async function loadAgents() {
      if (!state.currentProject) {
        return;
      }

      try {
        const data = await api.getAgents(state.currentProject);
        const agents = data.agents || [];

        // Convert to state.agents format { agentName: { fr: [...], en: [...] } }
        state.agents = {};
        agents.forEach(a => {
          state.agents[a.name] = {
            fr: a.sections?.fr || [],
            en: a.sections?.en || []
          };
        });

        state.protectedTokens = (await api.getProtectedTokens()).tokens || [];
      } catch (error) {
        showToast(`Erreur agents: ${error.message}`, 'error');
      }
    }

    function renderSections(agent, lang) {
      const sections = state.agents[agent]?.[lang] || [];
      const list = document.getElementById('sections-list');

      // Element may not exist in split-only mode
      if (!list) return;

      if (sections.length === 0) {
        list.innerHTML = `<li class="section-item" style="color: var(--text-muted);">
          Aucune section ${lang.toUpperCase()}
        </li>`;
        // Add create button even if no sections
        list.innerHTML += `
          <button class="add-section-btn" onclick="openCreateSectionModal()">
            <span>&#10133;</span> Ajouter une section
          </button>
        `;
        return;
      }

      list.innerHTML = sections.map((section, index) => {
        const num = section.match(/^(\d+)/)?.[1] || '';
        const name = section.replace(/^\d+-/, '').replace('.md', '');
        const otherLang = lang === 'fr' ? 'en' : 'fr';
        const hasOther = state.agents[agent]?.[otherLang]?.includes(section);
        const isFirst = index === 0;
        const isLast = index === sections.length - 1;

        return `
          <li class="section-item" data-section="${section}" data-index="${index}">
            <span class="section-num">${num}</span>
            <span class="section-name">${name}</span>
            <span class="lang-badge ${hasOther ? '' : 'missing'}">${hasOther ? otherLang.toUpperCase() : '!'}</span>
            <span class="section-actions">
              <button class="section-action-btn" title="Monter" onclick="event.stopPropagation(); moveSection(${index}, -1)" ${isFirst ? 'disabled style="opacity:0.3"' : ''}>&#9650;</button>
              <button class="section-action-btn" title="Descendre" onclick="event.stopPropagation(); moveSection(${index}, 1)" ${isLast ? 'disabled style="opacity:0.3"' : ''}>&#9660;</button>
              <button class="section-action-btn danger" title="Supprimer" onclick="event.stopPropagation(); openDeleteModal('${section}')">&#128465;</button>
            </span>
          </li>
        `;
      }).join('');

      // Add create button at the end
      list.innerHTML += `
        <button class="add-section-btn" onclick="openCreateSectionModal()">
          <span>&#10133;</span> Ajouter une section
        </button>
      `;

      // Add click handlers for loading sections
      list.querySelectorAll('.section-item[data-section]').forEach(item => {
        item.addEventListener('click', (e) => {
          // Don't trigger if clicking on action buttons
          if (e.target.closest('.section-actions')) return;
          loadSection(agent, lang, item.dataset.section);
        });
      });

      // Also render the floating nav
      renderFloatingSections();
    }

    // ============================================
    // FLOATING SECTIONS NAV
    // ============================================
    function renderFloatingSections() {
      const sections = state.agents[state.currentAgent]?.[state.currentLang] || [];
      const container = document.getElementById('floating-sections-list');

      if (!container) return;

      container.innerHTML = sections.map((section, index) => {
        const num = section.match(/^(\d+)/)?.[1] || String(index + 1).padStart(2, '0');
        const name = section.replace(/^\d+-/, '').replace('.md', '');
        const isActive = section === state.currentSection;

        return `
          <div class="floating-section-item ${isActive ? 'active' : ''}"
               data-section="${section}"
               data-index="${index}"
               draggable="${state.isReorderMode ? 'true' : 'false'}">
            <span class="floating-section-num">${num}</span>
            <span class="floating-section-name">${name}</span>
          </div>
        `;
      }).join('');

      // Add click handlers
      container.querySelectorAll('.floating-section-item').forEach(item => {
        item.addEventListener('click', () => {
          if (state.isReorderMode) return;
          const section = item.dataset.section;
          scrollToSectionInEditor(section);
        });

        // Drag events for reorder mode
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('dragleave', handleDragLeave);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragend', handleDragEnd);
      });
    }

    function scrollToSectionInEditor(sectionName) {
      const boundary = state.sectionBoundaries.find(b => b.section === sectionName);
      if (boundary && state.editor) {
        state.editor.revealLineInCenter(boundary.startLine);
        state.editor.setPosition({ lineNumber: boundary.startLine, column: 1 });
        state.editor.focus();

        // Update active state in floating nav
        document.querySelectorAll('.floating-section-item').forEach(item => {
          item.classList.toggle('active', item.dataset.section === sectionName);
        });
        // Update active state in sidebar
        document.querySelectorAll('#sections-list .section-item').forEach(item => {
          item.classList.toggle('active', item.dataset.section === sectionName);
        });

        state.currentSection = sectionName;
      }
    }

    // ============================================
    // REORDER MODE (Drag & Drop)
    // ============================================
    function toggleReorderMode() {
      state.isReorderMode = !state.isReorderMode;
      const nav = document.getElementById('floating-sections-nav');
      const btn = document.getElementById('btn-reorder');

      nav.classList.toggle('reorder-mode', state.isReorderMode);
      btn.classList.toggle('active', state.isReorderMode);

      // Re-render to update draggable attribute
      renderFloatingSections();

      if (state.isReorderMode) {
        // Add click outside listener
        setTimeout(() => {
          document.addEventListener('click', closeReorderOnOutsideClick);
        }, 0);
      } else {
        document.removeEventListener('click', closeReorderOnOutsideClick);
      }
    }

    function closeReorderOnOutsideClick(e) {
      const nav = document.getElementById('floating-sections-nav');
      if (!nav.contains(e.target)) {
        toggleReorderMode();
      }
    }

    let draggedElement = null;
    let draggedIndex = null;

    function handleDragStart(e) {
      if (!state.isReorderMode) return;
      draggedElement = e.target.closest('.floating-section-item');
      draggedIndex = parseInt(draggedElement.dataset.index);
      draggedElement.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
      e.preventDefault();
      if (!state.isReorderMode) return;
      e.dataTransfer.dropEffect = 'move';
      const target = e.target.closest('.floating-section-item');
      if (target && target !== draggedElement) {
        target.classList.add('drag-over');
      }
    }

    function handleDragLeave(e) {
      const target = e.target.closest('.floating-section-item');
      if (target) {
        target.classList.remove('drag-over');
      }
    }

    async function handleDrop(e) {
      e.preventDefault();
      if (!state.isReorderMode || !draggedElement) return;

      const target = e.target.closest('.floating-section-item');
      if (!target || target === draggedElement) return;

      target.classList.remove('drag-over');

      const targetIndex = parseInt(target.dataset.index);
      if (targetIndex === draggedIndex) return;

      // Get current sections order
      const sections = [...(state.agents[state.currentAgent]?.[state.currentLang] || [])];

      // Reorder
      const [removed] = sections.splice(draggedIndex, 1);
      sections.splice(targetIndex, 0, removed);

      try {
        showLoading(true, 'R√©organisation...');

        const result = await api.reorderSections(
          state.currentProject,
          state.currentAgent,
          state.currentLang,
          sections
        );

        // Update state with new order and renamed files
        const updatedSections = sections.map(oldName => result.mapping[oldName] || oldName);
        state.agents[state.currentAgent][state.currentLang] = updatedSections;

        // Re-render everything
        renderSections(state.currentAgent, state.currentLang);
        await loadAllSections(state.currentAgent, state.currentLang);

        showLoading(false);
        showToast('Ordre mis √† jour !', 'success');
      } catch (error) {
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    function handleDragEnd(e) {
      if (draggedElement) {
        draggedElement.classList.remove('dragging');
      }
      document.querySelectorAll('.floating-section-item.drag-over').forEach(el => {
        el.classList.remove('drag-over');
      });
      draggedElement = null;
      draggedIndex = null;
    }

    // ============================================
    // SPLIT MODE
    // ============================================
    function toggleSplitMode() {
      state.splitMode = !state.splitMode;
      const app = document.getElementById('app');
      const btn = document.getElementById('btn-split');

      app.classList.toggle('split-mode', state.splitMode);
      btn.classList.toggle('active', state.splitMode);
      btn.innerHTML = state.splitMode
        ? '<span>&#9707;</span> Normal'
        : '<span>&#9707;</span> Split';

      if (state.splitMode) {
        initSplitMode();
      } else {
        // Clean up split editors
        if (state.panels.left.editor) {
          state.panels.left.editor.dispose();
          state.panels.left.editor = null;
        }
        if (state.panels.right.editor) {
          state.panels.right.editor.dispose();
          state.panels.right.editor = null;
        }
      }
    }

    function initSplitMode() {
      // Populate project selects for both panels
      populateSplitProjectSelects();

      // Initialize with current selection on left panel
      if (state.currentProject) {
        const leftProjectSelect = document.querySelector('.split-project-select[data-panel="left"]');
        leftProjectSelect.value = state.currentProject;
        onSplitProjectChange('left', state.currentProject);
      }
    }

    function populateSplitProjectSelects() {
      const selects = document.querySelectorAll('.split-project-select');
      selects.forEach(select => {
        select.innerHTML = '<option value="">-- Projet --</option>';
        state.projects.forEach(project => {
          const option = document.createElement('option');
          option.value = project.name;
          option.textContent = `${project.name} (${project.agents_count || 0} agents)`;
          select.appendChild(option);
        });
      });
    }

    async function onSplitProjectChange(panelId, project) {
      const panel = state.panels[panelId];
      panel.project = project;
      panel.agent = null;
      panel.sections = [];

      // Save to localStorage
      savePanelState(panelId);

      const agentSelect = document.querySelector(`.split-agent-select[data-panel="${panelId}"]`);
      agentSelect.innerHTML = '<option value="">-- Agent --</option>';

      if (!project) return;

      try {
        const agentsData = await api.getAgents(project);
        const agents = agentsData.agents || [];
        agents.forEach(agent => {
          const option = document.createElement('option');
          option.value = agent.name;
          option.textContent = agent.name;
          agentSelect.appendChild(option);
        });

        // If switching to split mode with current agent, select it on left panel
        const agentNames = agents.map(a => a.name);
        if (panelId === 'left' && state.currentAgent && agentNames.includes(state.currentAgent)) {
          agentSelect.value = state.currentAgent;
          await onSplitAgentChange(panelId, state.currentAgent);
        }
      } catch (err) {
        console.error('Failed to load agents for split panel:', err);
      }
    }

    async function onSplitAgentChange(panelId, agent) {
      const panel = state.panels[panelId];
      panel.agent = agent;

      // Save to localStorage
      savePanelState(panelId);

      if (!agent || !panel.project) {
        renderSplitFloatingNav(panelId);
        if (panel.editor) {
          panel.editor.setValue('');
        }
        return;
      }

      try {
        // Load sections for this agent
        const sections = await api.getSections(panel.project, agent, panel.lang);
        panel.sections = sections;

        // Load content for all sections
        await loadSplitPanelContent(panelId);
      } catch (err) {
        console.error('Failed to load sections for split panel:', err);
      }
    }

    // Save/restore panel state to localStorage
    function savePanelState(panelId) {
      const panel = state.panels[panelId];
      const key = `prompt-studio-panel-${panelId}`;
      localStorage.setItem(key, JSON.stringify({
        project: panel.project,
        agent: panel.agent,
        lang: panel.lang
      }));
    }

    function getSavedPanelState(panelId) {
      const key = `prompt-studio-panel-${panelId}`;
      const saved = localStorage.getItem(key);
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch (e) {
          return null;
        }
      }
      return null;
    }

    async function onSplitLangChange(panelId, lang) {
      const panel = state.panels[panelId];
      panel.lang = lang;

      // Save to localStorage
      savePanelState(panelId);

      // Update button states
      document.querySelectorAll(`.split-lang-btn[data-panel="${panelId}"]`).forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });

      // Reload content if agent is selected
      if (panel.agent && panel.project) {
        try {
          const sections = await api.getSections(panel.project, panel.agent, lang);
          panel.sections = sections;
          await loadSplitPanelContent(panelId);
        } catch (err) {
          console.error('Failed to reload sections after lang change:', err);
        }
      }
    }

    async function loadSplitPanelContent(panelId) {
      const panel = state.panels[panelId];
      if (!panel.project || !panel.agent || panel.sections.length === 0) {
        renderSplitFloatingNav(panelId);
        updateSplitExpandButton(panelId);
        return;
      }

      // Load all section contents
      const sectionsData = {};
      for (const section of panel.sections) {
        try {
          const content = await api.getSectionContent(panel.project, panel.agent, panel.lang, section);
          sectionsData[section] = content;
        } catch (err) {
          console.error(`Failed to load section ${section}:`, err);
          sectionsData[section] = '';
        }
      }

      // Concatenate sections
      const { content, boundaries } = concatenateSections(sectionsData, panel.sections);

      // Check for includes and expand automatically
      const hasIncludes = content.includes('{% include');
      panel.hasIncludes = hasIncludes;

      let displayContent = content;
      if (hasIncludes) {
        try {
          const expandResult = await expandContentWithIncludesForPanel(content, panel.lang, panel.project);
          displayContent = expandResult.expanded;
          panel.isExpanded = true;
        } catch (err) {
          console.error('Failed to expand includes:', err);
          panel.isExpanded = false;
        }
      } else {
        panel.isExpanded = false;
      }

      panel.originalContent = displayContent;
      panel.originalSections = { ...sectionsData };
      panel.sectionBoundaries = boundaries;

      // Initialize or update editor
      if (!panel.editor) {
        initSplitPanelEditor(panelId);
      }
      panel.editor.setValue(displayContent);

      // Render floating nav and update expand button
      renderSplitFloatingNav(panelId);
      updateSplitExpandButton(panelId);
      addSplitIncludeDecorations(panelId);
    }

    function initSplitPanelEditor(panelId) {
      const panel = state.panels[panelId];
      const containerId = panelId === 'left' ? 'split-monaco-left' : 'split-monaco-right';
      const container = document.getElementById(containerId);

      panel.editor = monaco.editor.create(container, {
        value: '',
        language: 'markdown',
        theme: 'vs-dark',
        fontSize: 14,
        wordWrap: 'on',
        minimap: { enabled: false },
        automaticLayout: true,
        scrollBeyondLastLine: false,
        lineNumbers: 'on',
        renderLineHighlight: 'all',
        folding: true,
        foldingStrategy: 'indentation'
      });

      // Add "Insert Include" action to context menu
      panel.editor.addAction({
        id: `insert-include-${panelId}`,
        label: 'üìÇ Ins√©rer un Include',
        contextMenuGroupId: 'navigation',
        contextMenuOrder: 1.5,
        run: function(editor) {
          openInsertIncludeModal(panelId);
        }
      });

      // Add content change listener for auto-save
      panel.editor.onDidChangeModelContent(async () => {
        const currentContent = panel.editor.getValue();
        panel.isModified = currentContent !== panel.originalContent;

        // Auto-save logic
        if (panel.isModified) {
          clearTimeout(panel.saveTimeout);
          panel.saveTimeout = setTimeout(async () => {
            await saveSplitPanelContent(panelId);
          }, 1500);
        }
      });
    }

    // Expand includes for split panel (uses panel's project instead of global state)
    async function expandContentWithIncludesForPanel(content, lang, project) {
      const res = await fetch(`${CONFIG.apiBase}/expand`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content, lang, project }),
      });
      if (!res.ok) {
        return { expanded: content, has_includes: false };
      }
      return res.json();
    }

    // Collapse includes for split panel
    async function collapseContentWithIncludesForPanel(content, lang) {
      const res = await fetch(`${CONFIG.apiBase}/collapse-content`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content, lang }),
      });
      if (!res.ok) throw new Error('Failed to collapse includes');
      return res.json();
    }

    // Update expand/collapse button visibility and label
    function updateSplitExpandButton(panelId) {
      const panel = state.panels[panelId];
      const btn = document.querySelector(`.split-expand-btn[data-panel="${panelId}"]`);
      if (!btn) return;

      if (panel.hasIncludes) {
        btn.style.display = 'flex';
        const label = btn.querySelector('.expand-label');
        const icon = btn.querySelector('span:first-child');
        if (panel.isExpanded) {
          label.textContent = 'Collapse';
          icon.innerHTML = '&#128230;'; // üì¶
          btn.title = 'Remettre les {% include %} au lieu du contenu';
        } else {
          label.textContent = 'Expand';
          icon.innerHTML = '&#128194;'; // üìÇ
          btn.title = 'Afficher le contenu des includes';
        }
      } else {
        btn.style.display = 'none';
      }
    }

    // Toggle expand/collapse for split panel
    async function toggleSplitExpandIncludes(panelId) {
      const panel = state.panels[panelId];
      if (!panel.agent || !panel.hasIncludes || !panel.editor) return;

      try {
        showLoading(true, panel.isExpanded ? 'Collapsing includes...' : 'Expanding includes...');
        const content = panel.editor.getValue();

        if (panel.isExpanded) {
          // Collapse: replace expanded content with {% include %}
          const result = await collapseContentWithIncludesForPanel(content, panel.lang);
          panel.editor.setValue(result.collapsed);
          panel.isExpanded = false;
        } else {
          // Expand: replace {% include %} with actual content
          const result = await expandContentWithIncludesForPanel(content, panel.lang, panel.project);
          panel.editor.setValue(result.expanded);
          panel.isExpanded = true;
        }

        updateSplitExpandButton(panelId);
        addSplitIncludeDecorations(panelId);
        panel.isModified = false; // Don't mark as modified, just display change
        showLoading(false);
      } catch (error) {
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    // Add decorations for include markers in split panel editor
    function addSplitIncludeDecorations(panelId) {
      const panel = state.panels[panelId];
      if (!panel.editor || !panel.hasIncludes || !panel.isExpanded) return;

      const content = panel.editor.getValue();
      const lines = content.split('\n');
      const decorations = [];

      lines.forEach((line, index) => {
        const lineNum = index + 1;
        if (line.includes('<!-- @include-start:')) {
          decorations.push({
            range: new monaco.Range(lineNum, 1, lineNum, 100),
            options: {
              isWholeLine: true,
              className: 'include-start-line',
              glyphMarginClassName: 'include-glyph-start',
            }
          });
        } else if (line.includes('<!-- @include-end:')) {
          decorations.push({
            range: new monaco.Range(lineNum, 1, lineNum, 100),
            options: {
              isWholeLine: true,
              className: 'include-end-line',
              glyphMarginClassName: 'include-glyph-end',
            }
          });
        }
      });

      panel.editor.deltaDecorations([], decorations);
    }

    async function saveSplitPanelContent(panelId) {
      const panel = state.panels[panelId];
      if (!panel.project || !panel.agent || !panel.editor) return;

      const content = panel.editor.getValue();
      let savedCount = 0;

      // Check if content has expanded includes (with markers)
      const hasExpandedIncludes = content.includes('<!-- @include-start:');

      if (hasExpandedIncludes) {
        // First collapse to extract include contents
        try {
          const collapseResult = await collapseContentWithIncludesForPanel(content, panel.lang);
          const collapsedContent = collapseResult.collapsed;
          const modifiedIncludeFiles = collapseResult.modified_files || {};

          // Save include files directly via the API
          if (Object.keys(modifiedIncludeFiles).length > 0) {
            for (const [includeRef, includeContent] of Object.entries(modifiedIncludeFiles)) {
              // includeRef is like 'common/01-contexte.md'
              const [agent, filename] = includeRef.split('/');
              await api.saveSection(panel.project, agent, panel.lang, filename, includeContent);
              savedCount++;
            }
          }

          // Parse sections from collapsed content
          const parsedSections = parseSectionsFromContent(collapsedContent);

          // Save main sections that changed
          for (const [sectionName, sectionContent] of Object.entries(parsedSections)) {
            const originalContent = panel.originalSections[sectionName];
            if (sectionContent !== originalContent) {
              try {
                await api.saveSection(panel.project, panel.agent, panel.lang, sectionName, sectionContent);
                panel.originalSections[sectionName] = sectionContent;
                savedCount++;
              } catch (err) {
                console.error(`Failed to save section ${sectionName}:`, err);
              }
            }
          }
        } catch (err) {
          console.error('Failed to collapse includes:', err);
          showToast(`Erreur collapse includes: ${err.message}`, 'error');
          return;
        }
      } else {
        // No expanded includes - save normally
        const parsedSections = parseSectionsFromContent(content);

        for (const [sectionName, sectionContent] of Object.entries(parsedSections)) {
          if (sectionContent !== panel.originalSections[sectionName]) {
            try {
              await api.saveSection(panel.project, panel.agent, panel.lang, sectionName, sectionContent);
              panel.originalSections[sectionName] = sectionContent;
              savedCount++;
            } catch (err) {
              console.error(`Failed to save section ${sectionName}:`, err);
            }
          }
        }
      }

      panel.originalContent = content;
      panel.isModified = false;

      // Auto-generate prompt after save (like normal mode)
      if (savedCount > 0) {
        try {
          const result = await api.buildPrompt(panel.project, panel.agent, panel.lang);
          // Consider build successful if:
          // 1. result.success is true, OR
          // 2. result.exported is true and there's no actual error message
          const hasRealError = result.error && result.error.trim() !== '';
          const buildSucceeded = result.success || (result.exported && !hasRealError);

          if (buildSucceeded) {
            showToast(`${savedCount} section(s) sauvegard√©e(s), prompt ${panel.lang.toUpperCase()} g√©n√©r√© !`, 'success');
          } else {
            const errorMsg = result.stderr || result.error || result.message || 'Erreur inconnue';
            console.error('Build failed:', result);
            showToast(`${savedCount} section(s) sauvegard√©e(s), erreur build: ${errorMsg}`, 'warning');
          }
        } catch (err) {
          console.error('Build failed:', err);
          showToast(`${savedCount} section(s) sauvegard√©e(s), erreur build: ${err.message}`, 'warning');
        }
      }
    }

    function renderSplitFloatingNav(panelId) {
      const panel = state.panels[panelId];
      const nav = document.querySelector(`.split-floating-nav[data-panel="${panelId}"]`);
      const container = document.querySelector(`.split-sections-list[data-panel="${panelId}"]`);
      if (!container) return;

      container.innerHTML = panel.sections.map((section, index) => {
        const num = section.match(/^(\d+)/)?.[1] || String(index + 1).padStart(2, '0');
        const name = section.replace(/^\d+-/, '').replace('.md', '');
        return `
          <div class="floating-section-item" data-section="${section}" data-index="${index}" data-panel="${panelId}" draggable="true">
            <span class="floating-section-num">${num}</span>
            <span class="floating-section-name">${name}</span>
          </div>
        `;
      }).join('');

      // Add click and drag listeners
      container.querySelectorAll('.floating-section-item').forEach(item => {
        item.addEventListener('click', () => {
          const section = item.dataset.section;
          scrollToSectionInSplitEditor(panelId, section);
        });

        // Drag events
        item.addEventListener('dragstart', handleSplitDragStart);
        item.addEventListener('dragover', handleSplitDragOver);
        item.addEventListener('dragleave', handleSplitDragLeave);
        item.addEventListener('drop', handleSplitDrop);
        item.addEventListener('dragend', handleSplitDragEnd);
      });

      // Add or update the "+" button
      let addBtn = nav.querySelector('.split-add-section-btn');
      if (!addBtn && panel.project && panel.agent) {
        addBtn = document.createElement('button');
        addBtn.className = 'split-add-section-btn';
        addBtn.innerHTML = '+';
        addBtn.title = 'Ajouter une section';
        addBtn.dataset.panel = panelId;
        addBtn.addEventListener('click', () => openSplitCreateSectionModal(panelId));
        nav.appendChild(addBtn);
      } else if (addBtn && (!panel.project || !panel.agent)) {
        addBtn.remove();
      }
    }

    // Split mode drag & drop
    let splitDraggedElement = null;
    let splitDraggedIndex = null;
    let splitDraggedPanel = null;

    function handleSplitDragStart(e) {
      splitDraggedElement = e.target.closest('.floating-section-item');
      splitDraggedIndex = parseInt(splitDraggedElement.dataset.index);
      splitDraggedPanel = splitDraggedElement.dataset.panel;
      splitDraggedElement.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function handleSplitDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      const target = e.target.closest('.floating-section-item');
      // Only allow drop on same panel
      if (target && target !== splitDraggedElement && target.dataset.panel === splitDraggedPanel) {
        target.classList.add('drag-over');
      }
    }

    function handleSplitDragLeave(e) {
      const target = e.target.closest('.floating-section-item');
      if (target) {
        target.classList.remove('drag-over');
      }
    }

    async function handleSplitDrop(e) {
      e.preventDefault();
      if (!splitDraggedElement || !splitDraggedPanel) return;

      const target = e.target.closest('.floating-section-item');
      if (!target || target === splitDraggedElement || target.dataset.panel !== splitDraggedPanel) return;

      target.classList.remove('drag-over');

      const targetIndex = parseInt(target.dataset.index);
      if (targetIndex === splitDraggedIndex) return;

      // Capture panel ID before any async operation
      const panelId = splitDraggedPanel;
      const panel = state.panels[panelId];

      if (!panel || !panel.project || !panel.agent) {
        console.error('Invalid panel state for drop:', panelId, panel);
        return;
      }

      const sections = [...panel.sections];
      const fromIndex = splitDraggedIndex;

      // Reorder locally
      const [removed] = sections.splice(fromIndex, 1);
      sections.splice(targetIndex, 0, removed);

      try {
        showLoading(true, 'R√©organisation...');

        const result = await api.reorderSections(
          panel.project,
          panel.agent,
          panel.lang,
          sections
        );

        // Update state with new order and renamed files
        if (result && result.mapping) {
          panel.sections = sections.map(oldName => result.mapping[oldName] || oldName);
        } else {
          // Fallback: reload sections from server
          const data = await api.getAllSections(panel.project, panel.agent, panel.lang);
          panel.sections = data.order || Object.keys(data.sections || {});
        }

        // Reload content to update Monaco editor
        await loadSplitPanelContent(panelId);

        showLoading(false);
        showToast('Ordre mis √† jour !', 'success');
      } catch (error) {
        console.error('Drop error:', error);
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');

        // Reload to restore correct state
        try {
          const data = await api.getAllSections(panel.project, panel.agent, panel.lang);
          panel.sections = data.order || Object.keys(data.sections || {});
          await loadSplitPanelContent(panelId);
        } catch (reloadError) {
          console.error('Failed to reload after error:', reloadError);
        }
      }
    }

    function handleSplitDragEnd(e) {
      if (splitDraggedElement) {
        splitDraggedElement.classList.remove('dragging');
      }
      document.querySelectorAll('.floating-section-item.drag-over').forEach(el => {
        el.classList.remove('drag-over');
      });
      splitDraggedElement = null;
      splitDraggedIndex = null;
      splitDraggedPanel = null;
    }

    // Split mode: Create section modal
    function openSplitCreateSectionModal(panelId) {
      state.splitCreatePanelId = panelId;
      document.getElementById('new-section-name').value = '';
      document.getElementById('create-section-modal').classList.add('open');
    }

    function scrollToSectionInSplitEditor(panelId, sectionName) {
      const panel = state.panels[panelId];
      if (!panel.editor) return;

      const boundary = panel.sectionBoundaries.find(b => b.section === sectionName);
      if (boundary) {
        panel.editor.revealLineInCenter(boundary.delimiterLine);
        panel.editor.setPosition({ lineNumber: boundary.delimiterLine + 2, column: 1 });
        panel.editor.focus();
      }
    }

    // ============================================
    // SPLIT PANEL PREVIEW & DIFF
    // ============================================
    function toggleSplitPreview(panelId) {
      const panel = state.panels[panelId];
      const panelEl = document.getElementById(`split-panel-${panelId}`);
      const previewBtn = document.querySelector(`.split-preview-btn[data-panel="${panelId}"]`);
      const diffBtn = document.querySelector(`.split-diff-btn[data-panel="${panelId}"]`);

      // If diff mode is active, disable it first
      if (panelEl.classList.contains('diff-mode')) {
        panelEl.classList.remove('diff-mode');
        diffBtn.classList.remove('active');
      }

      // Toggle preview mode
      const isActive = panelEl.classList.toggle('preview-mode');
      previewBtn.classList.toggle('active', isActive);

      if (isActive) {
        updateSplitPreview(panelId);
      }
    }

    function updateSplitPreview(panelId) {
      const panel = state.panels[panelId];
      const previewEl = document.querySelector(`.split-preview-content[data-panel="${panelId}"]`);

      if (!panel.editor || !previewEl) return;

      const content = panel.editor.getValue();
      // Strip section delimiters for clean preview
      const cleanContent = content
        .replace(/<!-- ‚ïê+[^>]*-->/g, '')
        .replace(/<!-- üìÑ SECTION:[^>]*-->/g, '')
        .replace(/^---\s*$/gm, '')
        .replace(/^\s*[\r\n]/gm, '\n')
        .replace(/\n{3,}/g, '\n\n')
        .trim();

      previewEl.innerHTML = renderMarkdown(cleanContent || '');
    }

    function toggleSplitDiff(panelId) {
      const panel = state.panels[panelId];
      const panelEl = document.getElementById(`split-panel-${panelId}`);
      const previewBtn = document.querySelector(`.split-preview-btn[data-panel="${panelId}"]`);
      const diffBtn = document.querySelector(`.split-diff-btn[data-panel="${panelId}"]`);

      // If preview mode is active, disable it first
      if (panelEl.classList.contains('preview-mode')) {
        panelEl.classList.remove('preview-mode');
        previewBtn.classList.remove('active');
      }

      // Toggle diff mode
      const isActive = panelEl.classList.toggle('diff-mode');
      diffBtn.classList.toggle('active', isActive);

      if (isActive) {
        updateSplitDiff(panelId);
      }
    }

    function updateSplitDiff(panelId) {
      const panel = state.panels[panelId];
      const diffContainerId = `split-diff-${panelId}`;
      const diffContainer = document.getElementById(diffContainerId);

      if (!panel.editor || !diffContainer) return;

      const currentContent = panel.editor.getValue();
      const originalContent = panel.originalContent || '';

      // Dispose existing diff editor if any
      if (panel.diffEditor) {
        panel.diffEditor.dispose();
      }

      // Create diff editor
      panel.diffEditor = monaco.editor.createDiffEditor(diffContainer, {
        theme: 'vs-dark',
        readOnly: true,
        automaticLayout: true,
        renderSideBySide: true,
        scrollBeyondLastLine: false,
        minimap: { enabled: false }
      });

      panel.diffEditor.setModel({
        original: monaco.editor.createModel(originalContent, 'markdown'),
        modified: monaco.editor.createModel(currentContent, 'markdown')
      });
    }

    // ============================================
    // SECTION CONCATENATION & PARSING
    // ============================================
    function createSectionDelimiter(sectionName) {
      return `${SECTION_DELIMITER_START}\n<!-- üìÑ SECTION: ${sectionName} -->\n${SECTION_DELIMITER_START}`;
    }

    function concatenateSections(sectionsData, order) {
      const parts = [];
      const boundaries = [];
      let currentLine = 1;

      order.forEach((sectionName, index) => {
        const content = sectionsData[sectionName] || '';

        // Add delimiter
        const delimiter = createSectionDelimiter(sectionName);
        parts.push(delimiter);

        const delimiterLines = delimiter.split('\n').length;
        const startLine = currentLine + delimiterLines;

        // Add content
        parts.push(content);

        const contentLines = content.split('\n').length;
        const endLine = startLine + contentLines - 1;

        boundaries.push({
          section: sectionName,
          delimiterLine: currentLine,
          startLine: startLine,
          endLine: endLine,
        });

        currentLine = endLine + 2; // +2 for the blank line between sections

        // Add blank line between sections (except last)
        if (index < order.length - 1) {
          parts.push('');
        }
      });

      return {
        content: parts.join('\n'),
        boundaries: boundaries,
      };
    }

    function parseSectionsFromContent(content) {
      const sections = {};
      const lines = content.split('\n');

      let currentSection = null;
      let currentContent = [];

      for (const line of lines) {
        const match = line.match(SECTION_DELIMITER_PATTERN);
        if (match) {
          // Save previous section if exists
          if (currentSection) {
            sections[currentSection] = currentContent.join('\n').trim();
          }
          currentSection = match[1];
          currentContent = [];
        } else if (currentSection && !line.startsWith('<!-- ‚ïê')) {
          currentContent.push(line);
        }
      }

      // Save last section
      if (currentSection) {
        sections[currentSection] = currentContent.join('\n').trim();
      }

      return sections;
    }

    async function loadAllSections(agent, lang) {
      console.log('[loadAllSections] Called with agent:', agent, 'lang:', lang);

      if (state.isModified) {
        if (!confirm('Vous avez des modifications non sauvegard√©es. Continuer ?')) {
          return;
        }
      }

      try {
        showLoading(true, 'Chargement des sections...');
        const data = await api.getAllSections(state.currentProject, agent, lang);

        if (!data.order || data.order.length === 0) {
          state.editor.setValue('// Aucune section trouv√©e pour cet agent');
          showLoading(false);
          return;
        }

        // Store original sections
        state.originalSections = { ...data.sections };

        // Concatenate all sections
        const { content, boundaries } = concatenateSections(data.sections, data.order);

        // Expand includes automatiquement
        showLoading(true, 'R√©solution des includes...');
        const expandResult = await expandContentWithIncludes(content, lang);
        const displayContent = expandResult.expanded;
        state.hasIncludes = expandResult.has_includes;
        state.isExpanded = true;

        console.log('[loadAllSections] Setting state.currentAgent to:', agent);
        state.currentAgent = agent;
        state.currentLang = lang;
        state.currentSection = data.order[0]; // First section by default
        state.originalContent = displayContent;  // Store expanded content as original
        state.collapsedContent = content;  // Keep collapsed version for reference
        state.sectionBoundaries = boundaries;

        state.editor.setValue(displayContent);
        setModified(false);

        // Update UI
        document.getElementById('current-file').style.display = 'flex';
        document.getElementById('current-file-name').textContent = `${agent}/${lang}/ (${data.order.length} sections)`;

        // Update expand toggle button visibility and state
        updateExpandToggleButton();

        // Update sidebar - highlight first section
        document.querySelectorAll('.section-item').forEach(item => {
          item.classList.toggle('active', item.dataset.section === state.currentSection);
        });

        // Add Monaco decorations for section delimiters
        addSectionDecorations();
        // Add decorations for include markers
        addIncludeDecorations();

        await updatePreview(displayContent);

        showLoading(false);
      } catch (error) {
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    function scrollToSectionInEditor(sectionName) {
      const boundary = state.sectionBoundaries.find(b => b.section === sectionName);
      if (!boundary) return;

      // Update current section
      state.currentSection = sectionName;

      // Update sidebar highlighting
      document.querySelectorAll('.section-item').forEach(item => {
        item.classList.toggle('active', item.dataset.section === sectionName);
      });

      // Scroll editor to section
      state.editor.revealLineInCenter(boundary.startLine);

      // Highlight the section header briefly
      const decorations = state.editor.deltaDecorations([], [{
        range: new monaco.Range(boundary.delimiterLine, 1, boundary.delimiterLine + 2, 1),
        options: {
          isWholeLine: true,
          className: 'section-highlight-flash',
          glyphMarginClassName: 'section-glyph'
        }
      }]);

      // Remove highlight after animation
      setTimeout(() => {
        state.editor.deltaDecorations(decorations, []);
      }, 1500);
    }

    function addSectionDecorations() {
      if (!state.editor || !state.sectionBoundaries.length) return;

      const decorations = state.sectionBoundaries.map(b => ({
        range: new monaco.Range(b.delimiterLine, 1, b.delimiterLine + 2, 100),
        options: {
          isWholeLine: true,
          className: 'section-delimiter-line',
          glyphMarginClassName: 'section-glyph-marker',
        }
      }));

      state.editor.deltaDecorations([], decorations);
    }

    function addIncludeDecorations() {
      if (!state.editor || !state.hasIncludes) return;

      const content = state.editor.getValue();
      const lines = content.split('\n');
      const decorations = [];

      lines.forEach((line, index) => {
        const lineNum = index + 1;
        if (line.includes('<!-- @include-start:')) {
          // Start of include block - green decoration
          decorations.push({
            range: new monaco.Range(lineNum, 1, lineNum, 100),
            options: {
              isWholeLine: true,
              className: 'include-start-line',
              glyphMarginClassName: 'include-glyph-start',
            }
          });
        } else if (line.includes('<!-- @include-end:')) {
          // End of include block - green decoration
          decorations.push({
            range: new monaco.Range(lineNum, 1, lineNum, 100),
            options: {
              isWholeLine: true,
              className: 'include-end-line',
              glyphMarginClassName: 'include-glyph-end',
            }
          });
        }
      });

      state.editor.deltaDecorations([], decorations);
    }

    function updateExpandToggleButton() {
      const btn = document.getElementById('btn-toggle-expand');
      if (!btn) return;

      if (state.hasIncludes) {
        btn.style.display = 'flex';
        btn.innerHTML = state.isExpanded
          ? '<span>&#128230;</span> Collapse Includes'
          : '<span>&#128194;</span> Expand Includes';
        btn.title = state.isExpanded
          ? 'Remettre les {% include %} au lieu du contenu'
          : 'Afficher le contenu des includes';
      } else {
        btn.style.display = 'none';
      }
    }

    async function toggleExpandIncludes() {
      if (!state.currentAgent || !state.hasIncludes) return;

      try {
        showLoading(true, state.isExpanded ? 'Collapsing includes...' : 'Expanding includes...');
        const content = state.editor.getValue();

        if (state.isExpanded) {
          // Collapse: replace expanded content with {% include %}
          const result = await collapseContentWithIncludes(content, state.currentLang);
          state.editor.setValue(result.collapsed);
          state.isExpanded = false;
        } else {
          // Expand: replace {% include %} with actual content
          const result = await expandContentWithIncludes(content, state.currentLang);
          state.editor.setValue(result.expanded);
          state.isExpanded = true;
        }

        updateExpandToggleButton();
        addIncludeDecorations();
        setModified(false);  // Don't mark as modified, just display change
        showLoading(false);
      } catch (error) {
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    // Keep loadSection for backwards compatibility (single section load)
    async function loadSection(agent, lang, section) {
      // If we already have all sections loaded, just scroll
      if (state.currentAgent === agent && state.currentLang === lang && state.sectionBoundaries.length > 0) {
        scrollToSectionInEditor(section);
        return;
      }

      // Otherwise load all sections then scroll
      await loadAllSections(agent, lang);
      scrollToSectionInEditor(section);
    }

    // ============================================
    // SAVE
    // ============================================
    async function saveSection() {
      console.log('[saveSection] Called with state.currentAgent:', state.currentAgent);
      console.log('[saveSection] state.isModified:', state.isModified);
      console.log('[saveSection] state.currentProject:', state.currentProject);
      console.log('[saveSection] state.currentLang:', state.currentLang);
      if (!state.currentAgent || !state.isModified) {
        console.log('[saveSection] Early return: currentAgent=', state.currentAgent, 'isModified=', state.isModified);
        return;
      }

      // Validate state.currentAgent is a valid agent name (not content)
      if (state.currentAgent.includes('<!--') || state.currentAgent.includes('\n')) {
        console.error('[saveSection] Invalid state.currentAgent detected:', state.currentAgent.substring(0, 100));
        showToast('Erreur: Agent invalide. Rechargez la page.', 'error');
        return;
      }

      try {
        showLoading(true, 'Sauvegarde de toutes les sections...');
        const content = state.editor.getValue();

        console.log('[saveSection] Content length:', content.length);
        console.log('[saveSection] Content preview:', content.substring(0, 200));

        // Check if content has expanded includes (with markers)
        const hasExpandedIncludes = content.includes('<!-- @include-start:');
        console.log('[saveSection] hasExpandedIncludes:', hasExpandedIncludes);

        if (hasExpandedIncludes) {
          // First collapse to extract include contents
          showLoading(true, 'Extraction des includes modifi√©s...');
          const collapseResult = await collapseContentWithIncludes(content, state.currentLang);
          const collapsedContent = collapseResult.collapsed;
          const modifiedIncludeFiles = collapseResult.modified_files;

          // Save include files directly via the API
          if (Object.keys(modifiedIncludeFiles).length > 0) {
            showLoading(true, 'Sauvegarde des fichiers inclus...');
            for (const [includeRef, includeContent] of Object.entries(modifiedIncludeFiles)) {
              // includeRef is like 'common/01-contexte.md'
              const [agent, filename] = includeRef.split('/');
              await api.saveSection(state.currentProject, agent, state.currentLang, filename, includeContent);
            }
            showToast(`${Object.keys(modifiedIncludeFiles).length} fichier(s) include sauvegard√©(s)`, 'success');
          }

          // Parse sections from collapsed content
          const parsedSections = parseSectionsFromContent(collapsedContent);

          console.log('[saveSection-expanded] Parsed sections from collapsed:', Object.keys(parsedSections));
          console.log('[saveSection-expanded] Original sections:', Object.keys(state.originalSections));

          // Find which main sections changed
          const changedSections = {};
          for (const [name, newContent] of Object.entries(parsedSections)) {
            const originalContent = state.originalSections[name];
            const trimmedOriginal = originalContent ? originalContent.trim() : '';
            const trimmedNew = newContent ? newContent.trim() : '';

            console.log(`[saveSection-expanded] Section "${name}": original length=${trimmedOriginal.length}, new length=${trimmedNew.length}, equal=${trimmedOriginal === trimmedNew}`);

            if (trimmedOriginal !== trimmedNew) {
              changedSections[name] = newContent;
              console.log(`[saveSection-expanded] Section "${name}" marked as changed`);
            }
          }

          console.log('[saveSection-expanded] Changed sections count:', Object.keys(changedSections).length);

          if (Object.keys(changedSections).length > 0) {
            console.log('[saveSection-expanded] Calling api.saveAllSections with:', {
              project: state.currentProject,
              agent: state.currentAgent,
              lang: state.currentLang,
              sectionsCount: Object.keys(changedSections).length
            });
            await api.saveAllSections(state.currentProject, state.currentAgent, state.currentLang, changedSections);
            showToast(`${Object.keys(changedSections).length} section(s) principale(s) sauvegard√©e(s) !`, 'success');
          } else {
            console.log('[saveSection-expanded] No changed sections detected');
          }

          // Update original state - keep it expanded
          state.originalContent = content;
          state.originalSections = parsedSections;

        } else {
          // No expanded includes - save normally
          const parsedSections = parseSectionsFromContent(content);

          console.log('[saveSection] Parsed sections:', Object.keys(parsedSections));
          console.log('[saveSection] Original sections:', Object.keys(state.originalSections));

          // Find which sections changed
          const changedSections = {};
          for (const [name, newContent] of Object.entries(parsedSections)) {
            const originalContent = state.originalSections[name];
            const trimmedOriginal = originalContent ? originalContent.trim() : '';
            const trimmedNew = newContent ? newContent.trim() : '';

            console.log(`[saveSection] Section "${name}": original length=${trimmedOriginal.length}, new length=${trimmedNew.length}, equal=${trimmedOriginal === trimmedNew}`);

            if (trimmedOriginal !== trimmedNew) {
              changedSections[name] = newContent;
              console.log(`[saveSection] Section "${name}" marked as changed`);
            }
          }

          console.log('[saveSection] Changed sections count:', Object.keys(changedSections).length);
          console.log('[saveSection] Changed sections:', Object.keys(changedSections));

          if (Object.keys(changedSections).length === 0) {
            showLoading(false);
            showToast('Aucune modification d√©tect√©e', 'info');
            setModified(false);
            return;
          }

          // Save only changed sections
          console.log('[saveSection] Calling api.saveAllSections with:', {
            project: state.currentProject,
            agent: state.currentAgent,
            lang: state.currentLang,
            sectionsCount: Object.keys(changedSections).length
          });
          await api.saveAllSections(state.currentProject, state.currentAgent, state.currentLang, changedSections);

          // Update original state
          state.originalContent = content;
          state.originalSections = parsedSections;

          showToast(`${Object.keys(changedSections).length} section(s) sauvegard√©e(s) !`, 'success');
        }

        // Auto-generate after successful save
        await generatePrompt();

        setModified(false);
        showLoading(false);
      } catch (error) {
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    // ============================================
    // GENERATE
    // ============================================
    async function generatePrompt() {
      if (!state.currentAgent) {
        showToast('S√©lectionnez d\'abord un agent', 'warning');
        return;
      }

      try {
        showLoading(true, `G√©n√©ration ${state.currentLang.toUpperCase()}...`);
        const result = await api.buildPrompt(state.currentProject, state.currentAgent, state.currentLang);

        showLoading(false);
        // Consider build successful if:
        // 1. result.success is true, OR
        // 2. result.exported is true and there's no actual error message
        const hasRealError = result.error && result.error.trim() !== '';
        const buildSucceeded = result.success || (result.exported && !hasRealError);

        if (buildSucceeded) {
          showToast(`Prompt ${state.currentLang.toUpperCase()} g√©n√©r√© !`, 'success');
        } else {
          const errorMsg = result.stderr || result.error || result.message || 'Erreur inconnue';
          showToast(`Erreur: ${errorMsg}`, 'error');
        }
      } catch (error) {
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    // ============================================
    // TRANSLATE
    // ============================================
    function openTranslateModal() {
      if (!state.currentSection || state.currentLang !== 'fr') {
        showToast('Traduction disponible uniquement depuis FR', 'warning');
        return;
      }
      document.getElementById('translate-modal').classList.add('open');
      document.getElementById('translate-content').innerHTML = `
        <p>Traduire <strong>${state.currentSection}</strong> de FR vers EN ?</p>
        <p>Les tokens prot√©g√©s seront pr√©serv√©s.</p>
        <button class="btn btn-primary" onclick="doTranslate()" style="margin-top: 16px;">
          Lancer la traduction
        </button>
      `;
    }

    function closeTranslateModal() {
      document.getElementById('translate-modal').classList.remove('open');
    }

    async function doTranslate() {
      try {
        document.getElementById('translate-content').innerHTML = `
          <div style="text-align: center; padding: 40px;">
            <div class="loading-spinner" style="margin: 0 auto;"></div>
            <p style="margin-top: 16px;">Traduction en cours...</p>
          </div>
        `;

        const result = await api.translate(state.currentProject, state.currentAgent, state.currentSection);

        document.getElementById('translate-content').innerHTML = `
          <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
            <pre style="white-space: pre-wrap; font-size: 0.85rem;">${escapeHtml(result.translated)}</pre>
          </div>
        `;

        document.getElementById('btn-accept-translation').disabled = false;
        document.getElementById('btn-accept-translation').onclick = async () => {
          await api.saveSection(state.currentProject, state.currentAgent, 'en', state.currentSection, result.translated);
          showToast('Traduction sauvegard√©e !', 'success');
          closeTranslateModal();
          // Reload agents to update counts
          await loadAgents();
          if (state.currentAgent) {
            renderSections(state.currentAgent, state.currentLang);
          }
        };
      } catch (error) {
        document.getElementById('translate-content').innerHTML = `
          <p style="color: var(--accent-red);">Erreur: ${error.message}</p>
        `;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================
    // SECTION MANAGEMENT
    // ============================================
    let sectionToDelete = null;

    function openCreateSectionModal() {
      if (!state.currentAgent) {
        showToast('S√©lectionnez d\'abord un agent', 'warning');
        return;
      }
      document.getElementById('create-section-modal').classList.add('open');
      document.getElementById('new-section-name').value = '';
      document.getElementById('new-section-name').focus();
    }

    function closeCreateSectionModal() {
      document.getElementById('create-section-modal').classList.remove('open');
    }

    async function confirmCreateSection() {
      const name = document.getElementById('new-section-name').value.trim();
      if (!name) {
        showToast('Veuillez entrer un nom', 'warning');
        return;
      }

      // Sanitize name: lowercase, replace spaces with dashes, remove special chars
      const baseName = name
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, '');

      if (!baseName) {
        showToast('Nom invalide', 'error');
        return;
      }

      // Check if we're in split mode
      const panelId = state.splitCreatePanelId;
      const isSplitMode = panelId !== null;

      let project, agent, lang, existingSections;

      if (isSplitMode) {
        const panel = state.panels[panelId];
        project = panel.project;
        agent = panel.agent;
        lang = panel.lang;
        existingSections = panel.sections || [];
      } else {
        project = state.currentProject;
        agent = state.currentAgent;
        lang = state.currentLang;
        existingSections = state.agents[agent]?.[lang] || [];
      }

      // Calculate next number based on existing sections
      let maxNum = 0;
      existingSections.forEach(s => {
        const match = s.match(/^(\d+)-/);
        if (match) {
          const num = parseInt(match[1], 10);
          if (num > maxNum) maxNum = num;
        }
      });
      const nextNum = String(maxNum + 1).padStart(2, '0');
      const sanitizedName = `${nextNum}-${baseName}.md`;

      try {
        showLoading(true, 'Cr√©ation de la section...');
        const result = await api.createSection(project, agent, lang, sanitizedName);

        if (isSplitMode) {
          // Update split panel state and reload
          const panel = state.panels[panelId];
          panel.sections.push(result.section);
          panel.sections.sort();
          await loadSplitPanelContent(panelId);
        } else {
          // Update normal mode state
          if (!state.agents[agent][lang]) {
            state.agents[agent][lang] = [];
          }
          state.agents[agent][lang].push(result.section);
          state.agents[agent][lang].sort();
          renderSections(agent, lang);
          await loadAllSections(agent, lang);
        }

        closeCreateSectionModal();
        state.splitCreatePanelId = null;
        showLoading(false);
        showToast(`Section ${result.section} cr√©√©e !`, 'success');
      } catch (error) {
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    function openDeleteModal(section) {
      sectionToDelete = section;
      document.getElementById('delete-section-name').textContent = section;
      document.getElementById('delete-confirm-modal').classList.add('open');
    }

    function closeDeleteModal() {
      document.getElementById('delete-confirm-modal').classList.remove('open');
      sectionToDelete = null;
    }

    async function confirmDeleteSection() {
      if (!sectionToDelete) return;

      try {
        showLoading(true, 'Suppression...');
        await api.deleteSection(state.currentProject, state.currentAgent, state.currentLang, sectionToDelete);

        // Update local state
        const idx = state.agents[state.currentAgent][state.currentLang].indexOf(sectionToDelete);
        if (idx > -1) {
          state.agents[state.currentAgent][state.currentLang].splice(idx, 1);
        }

        // Clear editor if we deleted the current section (for main editor - may not exist)
        if (state.currentSection === sectionToDelete) {
          state.currentSection = null;
          if (state.editor) state.editor.setValue('');
          state.originalContent = '';
          setModified(false);
          const currentFile = document.getElementById('current-file');
          if (currentFile) currentFile.style.display = 'none';
          const previewContent = document.getElementById('preview-content');
          if (previewContent) previewContent.innerHTML = '<p style="color: var(--text-muted);">Section supprim√©e</p>';
        }

        closeDeleteModal();
        renderSections(state.currentAgent, state.currentLang);
        showLoading(false);
        showToast('Section supprim√©e !', 'success');
      } catch (error) {
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    // ============================================
    // INSERT INCLUDE MODAL
    // ============================================
    async function openInsertIncludeModal(panelId = null) {
      // Store which panel we're inserting into (for split mode)
      state.insertIncludePanelId = panelId;

      // Store cursor position before opening modal
      if (panelId && state.panels[panelId]?.editor) {
        // Split mode: use panel's editor
        state.insertIncludePosition = state.panels[panelId].editor.getPosition();
      } else if (state.editor) {
        // Normal mode: use main editor
        state.insertIncludePosition = state.editor.getPosition();
      } else {
        state.insertIncludePosition = null;
      }

      // Determine which project to pre-select
      let currentProject = state.currentProject;
      if (panelId && state.panels[panelId]?.project) {
        currentProject = state.panels[panelId].project;
      }

      try {
        // Load all projects
        const projectsData = await api.getProjects();

        const projectSelect = document.getElementById('include-project-select');
        projectSelect.innerHTML = '<option value="">-- S√©lectionner un projet --</option>';

        // Populate project dropdown
        for (const project of projectsData.projects) {
          const opt = document.createElement('option');
          opt.value = project.name;
          opt.textContent = project.name;
          // Pre-select current project if available
          if (project.name === currentProject) {
            opt.selected = true;
          }
          projectSelect.appendChild(opt);
        }

        // Reset agent and section dropdowns
        const agentSelect = document.getElementById('include-agent-select');
        agentSelect.innerHTML = '<option value="">-- S√©lectionner un agent --</option>';
        agentSelect.disabled = true;

        document.getElementById('include-section-select').innerHTML =
          '<option value="">-- S√©lectionner une section --</option>';
        document.getElementById('include-section-select').disabled = true;
        document.getElementById('btn-insert-include').disabled = true;

        // If current project is pre-selected, load its agents
        if (currentProject) {
          await onIncludeProjectChange();
        }

        updateIncludePreview();

        // Show modal
        document.getElementById('insert-include-modal').classList.add('open');
      } catch (error) {
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    function closeInsertIncludeModal() {
      document.getElementById('insert-include-modal').classList.remove('open');
    }

    async function onIncludeProjectChange() {
      const projectSelect = document.getElementById('include-project-select');
      const agentSelect = document.getElementById('include-agent-select');
      const sectionSelect = document.getElementById('include-section-select');
      const selectedProject = projectSelect.value;

      // Reset agent and section dropdowns
      agentSelect.innerHTML = '<option value="">-- S√©lectionner un agent --</option>';
      sectionSelect.innerHTML = '<option value="">-- S√©lectionner une section --</option>';
      sectionSelect.disabled = true;
      document.getElementById('btn-insert-include').disabled = true;

      if (selectedProject) {
        try {
          // Load agents for selected project
          const agentsData = await api.getAgents(selectedProject);

          // Group sections by agent
          state.availableIncludes = {};
          for (const agent of agentsData.agents) {
            state.availableIncludes[agent.name] = agent.sections[state.currentLang] || [];
          }

          // Populate agent dropdown
          for (const agent of agentsData.agents) {
            const opt = document.createElement('option');
            opt.value = agent.name;
            opt.textContent = agent.name;
            agentSelect.appendChild(opt);
          }

          agentSelect.disabled = false;
        } catch (error) {
          showToast(`Erreur: ${error.message}`, 'error');
          agentSelect.disabled = true;
        }
      } else {
        agentSelect.disabled = true;
      }

      updateIncludePreview();
    }

    function onIncludeAgentChange() {
      const agentSelect = document.getElementById('include-agent-select');
      const sectionSelect = document.getElementById('include-section-select');
      const selectedAgent = agentSelect.value;

      sectionSelect.innerHTML = '<option value="">-- S√©lectionner une section --</option>';

      if (selectedAgent && state.availableIncludes[selectedAgent]) {
        const sections = state.availableIncludes[selectedAgent];
        for (const section of sections) {
          const opt = document.createElement('option');
          opt.value = section;
          opt.textContent = section;
          sectionSelect.appendChild(opt);
        }
        sectionSelect.disabled = false;
      } else {
        sectionSelect.disabled = true;
      }

      document.getElementById('btn-insert-include').disabled = true;
      updateIncludePreview();
    }

    function onIncludeSectionChange() {
      const sectionSelect = document.getElementById('include-section-select');
      document.getElementById('btn-insert-include').disabled = !sectionSelect.value;
      updateIncludePreview();
    }

    function updateIncludePreview() {
      const project = document.getElementById('include-project-select').value;
      const agent = document.getElementById('include-agent-select').value;
      const section = document.getElementById('include-section-select').value;
      const preview = document.getElementById('include-preview');

      if (project && agent && section) {
        // If same project, use short format: agent/section.md
        // If different project, use full format: project/agent/section.md
        if (project === state.currentProject) {
          preview.textContent = `{% include '${agent}/${section}' %}`;
        } else {
          preview.textContent = `{% include '${project}/${agent}/${section}' %}`;
        }
      } else {
        preview.textContent = `{% include '' %}`;
      }
    }

    function insertIncludeAtCursor() {
      const project = document.getElementById('include-project-select').value;
      const agent = document.getElementById('include-agent-select').value;
      const section = document.getElementById('include-section-select').value;

      if (!project || !agent || !section) return;

      // Determine current project based on context (split panel or main)
      const panelId = state.insertIncludePanelId;
      let currentProject = state.currentProject;
      let targetEditor = state.editor;

      if (panelId && state.panels[panelId]) {
        // Split mode
        currentProject = state.panels[panelId].project;
        targetEditor = state.panels[panelId].editor;
      }

      // If same project, use short format: agent/section.md
      // If different project, use full format: project/agent/section.md
      let includePath;
      if (project === currentProject) {
        includePath = `${agent}/${section}`;
      } else {
        includePath = `${project}/${agent}/${section}`;
      }

      const includeText = `{% include '${includePath}' %}`;

      // Check if we have a target editor
      if (!targetEditor) {
        // Copy to clipboard instead
        navigator.clipboard.writeText(includeText).then(() => {
          showToast('Include copi√© dans le presse-papier', 'success');
        });
        closeInsertIncludeModal();
        return;
      }

      const position = state.insertIncludePosition || targetEditor.getPosition();

      // Insert text at cursor position
      targetEditor.executeEdits('insert-include', [{
        range: new monaco.Range(
          position.lineNumber,
          position.column,
          position.lineNumber,
          position.column
        ),
        text: includeText,
        forceMoveMarkers: true
      }]);

      // Focus editor and move cursor after inserted text
      targetEditor.focus();
      const newColumn = position.column + includeText.length;
      targetEditor.setPosition({ lineNumber: position.lineNumber, column: newColumn });

      // Mark as modified
      if (panelId && state.panels[panelId]) {
        state.panels[panelId].isModified = true;
      } else {
        setModified(true);
      }

      // Close modal
      closeInsertIncludeModal();

      showToast('Include ins√©r√©', 'success');
    }

    // Helper function to load include completions from ALL projects
    async function loadIncludeCompletions() {
      try {
        // Load all projects
        const projectsData = await api.getProjects();
        state.includeCompletions = [];

        for (const project of projectsData.projects) {
          const projectName = project.name;
          try {
            const agentsData = await api.getAgents(projectName);

            for (const agent of agentsData.agents) {
              const sections = agent.sections[state.currentLang] || [];
              for (const section of sections) {
                // For current project, use short format
                // For other projects, use full format
                const ref = (projectName === state.currentProject)
                  ? `${agent.name}/${section}`
                  : `${projectName}/${agent.name}/${section}`;

                state.includeCompletions.push({
                  project: projectName,
                  agent: agent.name,
                  section: section,
                  ref: ref,
                  isCurrentProject: projectName === state.currentProject
                });
              }
            }
          } catch (error) {
            console.warn(`Failed to load agents for project ${projectName}:`, error);
          }
        }

        // Sort: current project first, then alphabetically
        state.includeCompletions.sort((a, b) => {
          if (a.isCurrentProject && !b.isCurrentProject) return -1;
          if (!a.isCurrentProject && b.isCurrentProject) return 1;
          return a.ref.localeCompare(b.ref);
        });
      } catch (error) {
        console.error('Failed to load include completions:', error);
      }
    }

    async function moveSection(index, direction) {
      const sections = state.agents[state.currentAgent]?.[state.currentLang] || [];
      const newIndex = index + direction;

      if (newIndex < 0 || newIndex >= sections.length) return;

      // Swap sections in the array
      const newOrder = [...sections];
      [newOrder[index], newOrder[newIndex]] = [newOrder[newIndex], newOrder[index]];

      try {
        showLoading(true, 'R√©organisation...');
        const result = await api.reorderSections(state.currentProject, state.currentAgent, state.currentLang, newOrder);

        // Update local state with new names from mapping
        const updatedSections = newOrder.map(oldName => result.mapping[oldName] || oldName);
        state.agents[state.currentAgent][state.currentLang] = updatedSections;

        // Update current section name if it was renamed
        if (state.currentSection && result.mapping[state.currentSection]) {
          state.currentSection = result.mapping[state.currentSection];
          document.getElementById('current-file-name').textContent =
            `${state.currentAgent}/${state.currentLang}/${state.currentSection}`;
        }

        renderSections(state.currentAgent, state.currentLang);
        showToast('Ordre mis √† jour !', 'success');

        // Reload all sections in editor with new order
        await loadAllSections(state.currentAgent, state.currentLang);
      } catch (error) {
        showLoading(false);
        showToast(`Erreur: ${error.message}`, 'error');
      }
    }

    // ============================================
    // COLLAPSE SIDEBAR & PREVIEW
    // ============================================
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const app = document.getElementById('app');
      const btn = document.getElementById('collapse-sidebar-btn');

      const isCollapsed = sidebar.classList.toggle('collapsed');
      app.classList.toggle('sidebar-collapsed', isCollapsed);

      // Update button icon
      btn.textContent = isCollapsed ? '‚ñ∂' : '‚óÄ';

      // Trigger Monaco layout refresh
      setTimeout(() => {
        state.editor?.layout();
      }, 350); // After CSS transition
    }

    function togglePreview() {
      const preview = document.getElementById('preview-pane');
      const resizer = document.getElementById('resizer');
      const btn = document.getElementById('collapse-preview-btn');

      const isCollapsed = preview.classList.toggle('collapsed');
      resizer.classList.toggle('hidden', isCollapsed);

      // Update button icon
      btn.textContent = isCollapsed ? '‚óÄ' : '‚ñ∂';

      // Trigger Monaco layout refresh
      setTimeout(() => {
        state.editor?.layout();
      }, 350); // After CSS transition
    }

    // ============================================
    // SCROLL SYNCHRONIZATION
    // ============================================
    let isSyncingScroll = false;
    let scrollSyncEnabled = true; // Can be toggled if needed

    function initScrollSync() {
      if (!state.editor) return;

      // Sync editor ‚Üí preview
      state.editor.onDidScrollChange((e) => {
        if (isSyncingScroll || !scrollSyncEnabled) return;

        const previewPane = document.getElementById('preview-pane');
        const preview = document.getElementById('preview-content');
        if (!preview || previewPane?.classList.contains('collapsed')) return;

        const scrollTop = e.scrollTop;
        const scrollHeight = state.editor.getScrollHeight();
        const clientHeight = state.editor.getLayoutInfo().height;

        // Avoid division by zero
        const maxScroll = scrollHeight - clientHeight;
        if (maxScroll <= 0) return;

        // Calculate scroll percentage
        const scrollPercent = Math.min(1, Math.max(0, scrollTop / maxScroll));

        // Apply to preview
        const previewMaxScroll = preview.scrollHeight - preview.clientHeight;

        if (previewMaxScroll > 0) {
          isSyncingScroll = true;
          preview.scrollTop = Math.round(scrollPercent * previewMaxScroll);
          setTimeout(() => isSyncingScroll = false, 100);
        }
      });

      // Sync preview ‚Üí editor
      const previewEl = document.getElementById('preview-content');
      if (previewEl) {
        previewEl.addEventListener('scroll', (e) => {
          if (isSyncingScroll || !scrollSyncEnabled) return;
          if (!state.editor) return;

          const preview = e.target;
          const previewMaxScroll = preview.scrollHeight - preview.clientHeight;

          // Avoid division by zero
          if (previewMaxScroll <= 0) return;

          const scrollPercent = Math.min(1, Math.max(0, preview.scrollTop / previewMaxScroll));

          const editorScrollHeight = state.editor.getScrollHeight();
          const editorClientHeight = state.editor.getLayoutInfo().height;
          const editorMaxScroll = editorScrollHeight - editorClientHeight;

          if (editorMaxScroll > 0) {
            isSyncingScroll = true;
            state.editor.setScrollTop(Math.round(scrollPercent * editorMaxScroll));
            setTimeout(() => isSyncingScroll = false, 100);
          }
        }, { passive: true });
      }
    }

    // ============================================
    // RESIZER
    // ============================================
    function initResizer() {
      const resizer = document.getElementById('resizer');
      const editorPane = document.querySelector('.editor-pane');
      const previewPane = document.querySelector('.preview-pane');
      let isResizing = false;

      resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        document.body.style.cursor = 'col-resize';
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const container = document.querySelector('.editor-container');
        const containerRect = container.getBoundingClientRect();
        const percent = ((e.clientX - containerRect.left) / containerRect.width) * 100;

        if (percent > 20 && percent < 80) {
          editorPane.style.flex = `0 0 ${percent}%`;
          previewPane.style.flex = `0 0 ${100 - percent}%`;
        }
      });

      document.addEventListener('mouseup', () => {
        isResizing = false;
        document.body.style.cursor = '';
      });
    }

    // ============================================
    // KEYBOARD SHORTCUTS
    // ============================================
    document.addEventListener('keydown', (e) => {
      // Ctrl+S: Save
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveSection();
      }
      // Ctrl+D: Diff
      if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault();
        showDiff();
      }
      // Escape: Close panels
      if (e.key === 'Escape') {
        closeDiff();
        closeTranslateModal();
        closeCreateSectionModal();
        closeDeleteModal();
      }
      // Enter in create section modal
      if (e.key === 'Enter' && document.getElementById('create-section-modal').classList.contains('open')) {
        e.preventDefault();
        confirmCreateSection();
      }
    });

    // ============================================
    // EVENT LISTENERS
    // ============================================
    document.addEventListener('DOMContentLoaded', () => {
      initMonaco(() => {
        loadProjects();  // Load projects first (multi-projet)
      });

      // Include section select - for insert include modal
      document.getElementById('include-section-select').addEventListener('change', onIncludeSectionChange);

      // Split mode selectors
      document.querySelectorAll('.split-project-select').forEach(select => {
        select.addEventListener('change', (e) => {
          const panelId = e.target.dataset.panel;
          onSplitProjectChange(panelId, e.target.value);
        });
      });

      document.querySelectorAll('.split-agent-select').forEach(select => {
        select.addEventListener('change', (e) => {
          const panelId = e.target.dataset.panel;
          onSplitAgentChange(panelId, e.target.value);
        });
      });

      document.querySelectorAll('.split-lang-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const panelId = e.target.dataset.panel;
          const lang = e.target.dataset.lang;
          onSplitLangChange(panelId, lang);
        });
      });

      // Split mode: Preview buttons
      document.querySelectorAll('.split-preview-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const panelId = e.target.closest('.split-preview-btn').dataset.panel;
          toggleSplitPreview(panelId);
        });
      });

      // Split mode: Diff buttons
      document.querySelectorAll('.split-diff-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const panelId = e.target.closest('.split-diff-btn').dataset.panel;
          toggleSplitDiff(panelId);
        });
      });

      // Split mode: Expand/Collapse buttons
      document.querySelectorAll('.split-expand-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const panelId = e.target.closest('.split-expand-btn').dataset.panel;
          toggleSplitExpandIncludes(panelId);
        });
      });
    });
  </script>
</body>

</html>